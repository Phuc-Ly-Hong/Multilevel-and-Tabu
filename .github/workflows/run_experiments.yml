name: Run Experiments with Comprehensive Results

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  compile:
    name: Compile C++
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y g++ bc
    
    - name: Compile executable
      run: |
        g++ -O2 -std=c++17 -o multilevel_tabu src/Multilevel_Tabu.cpp
        chmod +x multilevel_tabu
        ls -lh multilevel_tabu
    
    - name: Upload executable
      uses: actions/upload-artifact@v4
      with:
        name: multilevel-executable
        path: multilevel_tabu
        retention-days: 1

  run-small:
    name: Small ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 50
    
    strategy:
      fail-fast: false
      max-parallel: 12
      matrix:
        instance: [
          "10.5.1", "10.5.2", "10.5.3", "10.5.4",
          "10.10.1", "10.10.2", "10.10.3", "10.10.4",
          "10.20.1", "10.20.2", "10.20.3", "10.20.4",
          "20.5.1", "20.5.2", "20.5.3", "20.5.4",
          "20.10.1", "20.10.2", "20.10.3", "20.10.4",
          "20.20.1", "20.20.2", "20.20.3", "20.20.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance 5 times
      run: |
        chmod +x multilevel_tabu
        
        echo "üîÑ Running instance ${{ matrix.instance }} for 5 iterations..."
        
        for run in {1..5}; do
          echo ""
          echo "=========================================="
          echo "   RUN $run / 5"
          echo "=========================================="
          
          START_TIME=$(date +%s.%N)
          timeout 8m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output_run${run}.txt 2>&1 || true
          END_TIME=$(date +%s.%N)
          RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
          echo "$RUNTIME" > runtime_run${run}.txt
          
          echo "‚è±Ô∏è  Run $run completed in ${RUNTIME}s"
        done
        
        echo ""
        echo "‚úÖ All 5 runs completed!"
    
    - name: Parse and select best result
      run: |
        python3 <<'EOF'
        import re, json, os, glob
        instance = "${{ matrix.instance }}"
        
        def parse_output(output_file, runtime_file):
            """Parse m·ªôt output file v√† tr·∫£ v·ªÅ result dict"""
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_details = []
                
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                    
                    vehicle_pattern = re.compile(r'Vehicle (\d+):\s*(.+?)(?=Vehicle \d+:|Makespan:|$)', re.DOTALL)
                    for match in vehicle_pattern.finditer(solution_section):
                        vehicle_id = int(match.group(1))
                        vehicle_text = match.group(2)
                        
                        # Parse route
                        route_nodes = []
                        for token in vehicle_text.split():
                            if token.isdigit():
                                route_nodes.append(int(token))
                        
                        if len(route_nodes) >= 2:  # At least depot-depot
                            veh_makespan = veh_drone_viol = veh_waiting_viol = 0.0
                            
                            # T√¨m metrics c·ªßa xe n√†y
                            remaining_text = solution_section[match.end():match.end()+200]
                            for line in remaining_text.split('\n')[:5]:
                                if "Makespan:" in line:
                                    m = re.search(r'Makespan:\s*([\d.]+)', line)
                                    if m: veh_makespan = float(m.group(1))
                                if "Drone violation:" in line:
                                    m = re.search(r'Drone violation:\s*([\d.]+)', line)
                                    if m: veh_drone_viol = float(m.group(1))
                                if "Waiting violation:" in line:
                                    m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                                    if m: veh_waiting_viol = float(m.group(1))
                            
                            vehicle_details.append({
                                "vehicle_id": vehicle_id,
                                "route": route_nodes,
                                "route_str": " -> ".join(map(str, route_nodes)),
                                "makespan": round(veh_makespan, 4),
                                "drone_violation": round(veh_drone_viol, 4),
                                "waiting_violation": round(veh_waiting_viol, 4),
                                "num_customers": len(route_nodes) - 2
                            })
                
                if makespan == 0.0 and fitness > 0.0: 
                    makespan = fitness
                
                return {
                    "instance": instance,
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "runtime_seconds": round(runtime, 3),
                    "feasible": (drone_viol < 0.01 and waiting_viol < 0.01),
                    "num_vehicles": len(vehicle_details),
                    "vehicles": vehicle_details
                }
            except Exception as e:
                return {"error": str(e), "fitness": float('inf')}
        
        # ========== PARSE T·∫§T C·∫¢ 5 RUNS ==========
        all_runs = []
        for run in range(1, 6):
            output_file = f"output_run{run}.txt"
            runtime_file = f"runtime_run{run}.txt"
            
            if os.path.exists(output_file):
                result = parse_output(output_file, runtime_file)
                result["run_number"] = run
                all_runs.append(result)
                
                status = '‚úÖ' if result.get('feasible', False) else '‚ö†Ô∏è'
                fitness = result.get('fitness', float('inf'))
                runtime = result.get('runtime_seconds', 0)
                print(f"{status} Run {run}: Fitness={fitness:.4f}, Runtime={runtime:.2f}s")
        
        # ========== CH·ªåN BEST RUN (FITNESS TH·∫§P NH·∫§T) ==========
        best_run = min(all_runs, key=lambda x: x.get('fitness', float('inf')))
        
        print(f"\nüèÜ BEST RUN: Run {best_run['run_number']}")
        print(f"   Fitness: {best_run['fitness']:.4f}")
        print(f"   Makespan: {best_run['makespan']:.4f}")
        print(f"   Feasible: {best_run['feasible']}")
        print(f"   Runtime: {best_run['runtime_seconds']:.2f}s")
        
        # ========== L∆ØU BEST RESULT ==========
        with open("result.json", "w") as f:
            json.dump(best_run, f, indent=2)
        
        # ========== L∆ØU ALL RUNS SUMMARY ==========
        with open("all_runs.json", "w") as f:
            json.dump(all_runs, f, indent=2)
        
        # ========== T·∫†O SUMMARY TABLE ==========
        print("\n" + "="*80)
        print(f"üìä SUMMARY FOR {instance}")
        print("="*80)
        print(f"{'Run':<6} {'Fitness':<12} {'Makespan':<12} {'Feasible':<10} {'Runtime':<10}")
        print("-"*80)
        
        for run_data in all_runs:
            run_num = run_data.get('run_number', 0)
            fitness = run_data.get('fitness', float('inf'))
            makespan = run_data.get('makespan', 0)
            feasible = 'YES' if run_data.get('feasible', False) else 'NO'
            runtime = run_data.get('runtime_seconds', 0)
            
            marker = 'üèÜ' if run_data == best_run else '  '
            print(f"{marker} {run_num:<4} {fitness:<12.4f} {makespan:<12.4f} {feasible:<10} {runtime:<10.2f}")
        
        print("="*80)
        
        # Statistics
        feasible_runs = [r for r in all_runs if r.get('feasible', False)]
        if feasible_runs:
            fitnesses = [r['fitness'] for r in feasible_runs]
            runtimes = [r['runtime_seconds'] for r in feasible_runs]
            
            print(f"\nüìà STATISTICS ({len(feasible_runs)}/5 feasible runs):")
            print(f"   Fitness:  Best={min(fitnesses):.4f}  Avg={sum(fitnesses)/len(fitnesses):.4f}  Worst={max(fitnesses):.4f}")
            print(f"   Runtime:  Best={min(runtimes):.2f}s  Avg={sum(runtimes)/len(runtimes):.2f}s  Worst={max(runtimes):.2f}s")
        
        EOF
    
    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          result.json
          all_runs.json
          output_run*.txt
        retention-days: 30

  run-medium:
    name: Medium ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 100
    
    strategy:
      fail-fast: false
      max-parallel: 8
      matrix:
        instance: [
          "50.10.1", "50.10.2", "50.10.3", "50.10.4",
          "50.20.1", "50.20.2", "50.20.3", "50.20.4",
          "50.30.1", "50.30.2", "50.30.3", "50.30.4",
          "50.40.1", "50.40.2", "50.40.3", "50.40.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance 5 times
      run: |
        chmod +x multilevel_tabu
        
        echo "üîÑ Running instance ${{ matrix.instance }} for 5 iterations..."
        
        for run in {1..5}; do
          echo ""
          echo "=========================================="
          echo "   RUN $run / 5"
          echo "=========================================="
          
          START_TIME=$(date +%s.%N)
          timeout 18m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output_run${run}.txt 2>&1 || true
          END_TIME=$(date +%s.%N)
          RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
          echo "$RUNTIME" > runtime_run${run}.txt
          
          echo "‚è±Ô∏è  Run $run completed in ${RUNTIME}s"
        done
        
        echo ""
        echo "‚úÖ All 5 runs completed!"
    
    - name: Parse and select best result
      run: |
        python3 <<'EOF'
        import re, json, os, glob
        instance = "${{ matrix.instance }}"
        
        def parse_output(output_file, runtime_file):
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_details = []
                
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                    
                    vehicle_pattern = re.compile(r'Vehicle (\d+):\s*(.+?)(?=Vehicle \d+:|Makespan:|$)', re.DOTALL)
                    for match in vehicle_pattern.finditer(solution_section):
                        vehicle_id = int(match.group(1))
                        vehicle_text = match.group(2)
                        
                        route_nodes = []
                        for token in vehicle_text.split():
                            if token.isdigit():
                                route_nodes.append(int(token))
                        
                        if len(route_nodes) >= 2:
                            vehicle_details.append({
                                "vehicle_id": vehicle_id,
                                "route": route_nodes,
                                "route_str": " -> ".join(map(str, route_nodes)),
                                "num_customers": len(route_nodes) - 2
                            })
                
                if makespan == 0.0 and fitness > 0.0: 
                    makespan = fitness
                
                return {
                    "instance": instance,
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "runtime_seconds": round(runtime, 3),
                    "feasible": (drone_viol < 0.01 and waiting_viol < 0.01),
                    "num_vehicles": len(vehicle_details),
                    "vehicles": vehicle_details
                }
            except Exception as e:
                return {"error": str(e), "fitness": float('inf')}
        
        all_runs = []
        for run in range(1, 6):
            result = parse_output(f"output_run{run}.txt", f"runtime_run{run}.txt")
            result["run_number"] = run
            all_runs.append(result)
            
            status = '‚úÖ' if result.get('feasible', False) else '‚ö†Ô∏è'
            print(f"{status} Run {run}: Fitness={result.get('fitness', float('inf')):.4f}")
        
        best_run = min(all_runs, key=lambda x: x.get('fitness', float('inf')))
        print(f"\nüèÜ BEST: Run {best_run['run_number']} - Fitness={best_run['fitness']:.4f}")
        
        with open("result.json", "w") as f:
            json.dump(best_run, f, indent=2)
        with open("all_runs.json", "w") as f:
            json.dump(all_runs, f, indent=2)
        EOF
    
    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          result.json
          all_runs.json
        retention-days: 30

  run-large:
    name: Large ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 200
    
    strategy:
      fail-fast: false
      max-parallel: 6
      matrix:
        instance: [
          "100.10.1", "100.10.2", "100.10.3", "100.10.4",
          "100.20.1", "100.20.2", "100.20.3", "100.20.4",
          "100.30.1", "100.30.2", "100.30.3", "100.30.4",
          "100.40.1", "100.40.2", "100.40.3", "100.40.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance 5 times
      run: |
        chmod +x multilevel_tabu
        
        echo "üîÑ Running instance ${{ matrix.instance }} for 5 iterations..."
        
        for run in {1..5}; do
          echo ""
          echo "=========================================="
          echo "   RUN $run / 5"
          echo "=========================================="
          
          START_TIME=$(date +%s.%N)
          timeout 35m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output_run${run}.txt 2>&1 || true
          END_TIME=$(date +%s.%N)
          RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
          echo "$RUNTIME" > runtime_run${run}.txt
          
          echo "‚è±Ô∏è  Run $run completed in ${RUNTIME}s"
        done
        
        echo ""
        echo "‚úÖ All 5 runs completed!"
    
    - name: Parse and select best result
      run: |
        python3 <<'EOF'
        import re, json, os
        instance = "${{ matrix.instance }}"
        
        def parse_output(output_file, runtime_file):
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_details = []
                
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                    
                    vehicle_pattern = re.compile(r'Vehicle (\d+):\s*(.+?)(?=Vehicle \d+:|Makespan:|$)', re.DOTALL)
                    for match in vehicle_pattern.finditer(solution_section):
                        vehicle_id = int(match.group(1))
                        vehicle_text = match.group(2)
                        
                        route_nodes = []
                        for token in vehicle_text.split():
                            if token.isdigit():
                                route_nodes.append(int(token))
                        
                        if len(route_nodes) >= 2:
                            vehicle_details.append({
                                "vehicle_id": vehicle_id,
                                "route": route_nodes,
                                "route_str": " -> ".join(map(str, route_nodes)),
                                "num_customers": len(route_nodes) - 2
                            })
                
                if makespan == 0.0 and fitness > 0.0: 
                    makespan = fitness
                
                return {
                    "instance": instance,
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "runtime_seconds": round(runtime, 3),
                    "feasible": (drone_viol < 0.01 and waiting_viol < 0.01),
                    "num_vehicles": len(vehicle_details),
                    "vehicles": vehicle_details
                }
            except Exception as e:
                return {"error": str(e), "fitness": float('inf')}
        
        all_runs = []
        for run in range(1, 6):
            result = parse_output(f"output_run{run}.txt", f"runtime_run{run}.txt")
            result["run_number"] = run
            all_runs.append(result)
            
            status = '‚úÖ' if result.get('feasible', False) else '‚ö†Ô∏è'
            print(f"{status} Run {run}: Fitness={result.get('fitness', float('inf')):.4f}")
        
        best_run = min(all_runs, key=lambda x: x.get('fitness', float('inf')))
        print(f"\nüèÜ BEST: Run {best_run['run_number']} - Fitness={best_run['fitness']:.4f}")
        
        with open("result.json", "w") as f:
            json.dump(best_run, f, indent=2)
        with open("all_runs.json", "w") as f:
            json.dump(all_runs, f, indent=2)
        EOF
    
    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          result.json
          all_runs.json
        retention-days: 30

  aggregate:
    name: Create Master CSV
    needs: [run-small, run-medium, run-large]
    runs-on: ubuntu-latest
    
    steps:
    - name: Download all results
      uses: actions/download-artifact@v4
      with:
        pattern: result-*
        merge-multiple: true
    
    - name: Create master comprehensive CSV
      run: |
        python3 <<'EOF'
        import json, glob, csv
        
        results = []
        for f in sorted(glob.glob("result.json")):
            try:
                with open(f) as file:
                    data = json.load(file)
                    if "error" not in data:
                        results.append(data)
            except:
                pass
        
        results.sort(key=lambda x: (
            int(x["instance"].split(".")[0]),
            int(x["instance"].split(".")[1]),
            int(x["instance"].split(".")[2])
        ))
        
        with open("MASTER_RESULTS.csv", "w", newline="", encoding="utf-8") as f:
            max_vehicles = max((r.get("num_vehicles", 0) for r in results), default=0)
            
            cols = [
                "Instance", "Instance_Size", "Num_Vehicles_Available", "Num_Customers",
                "Best_Run_Number", "Final_Fitness", "Final_Makespan", 
                "Total_Drone_Violation", "Total_Waiting_Violation",
                "Is_Feasible", "Runtime_Seconds", "Num_Vehicles_Used"
            ]
            
            for v in range(max_vehicles):
                cols.extend([f"V{v}_Route", f"V{v}_Num_Customers"])
            
            writer = csv.DictWriter(f, fieldnames=cols)
            writer.writeheader()
            
            for r in results:
                parts = r["instance"].split(".")
                
                row = {
                    "Instance": r["instance"],
                    "Instance_Size": int(parts[0]),
                    "Num_Vehicles_Available": int(parts[1]),
                    "Num_Customers": int(parts[0]),
                    "Best_Run_Number": r.get("run_number", 1),
                    "Final_Fitness": r.get("fitness", 0),
                    "Final_Makespan": r.get("makespan", 0),
                    "Total_Drone_Violation": r.get("drone_violation", 0),
                    "Total_Waiting_Violation": r.get("waiting_violation", 0),
                    "Is_Feasible": "YES" if r.get("feasible", False) else "NO",
                    "Runtime_Seconds": r.get("runtime_seconds", 0),
                    "Num_Vehicles_Used": r.get("num_vehicles", 0)
                }
                
                for v_idx, vehicle in enumerate(r.get("vehicles", [])):
                    if v_idx < max_vehicles:
                        row[f"V{v_idx}_Route"] = vehicle.get("route_str", "")
                        row[f"V{v_idx}_Num_Customers"] = vehicle.get("num_customers", 0)
                
                for v_idx in range(r.get("num_vehicles", 0), max_vehicles):
                    row[f"V{v_idx}_Route"] = ""
                    row[f"V{v_idx}_Num_Customers"] = 0
                
                writer.writerow(row)
        
        print("‚úÖ MASTER CSV CREATED with best results from 5 runs per instance")
        EOF
    
    - name: Upload master CSV
      uses: actions/upload-artifact@v4
      with:
        name: master-results
        path: MASTER_RESULTS.csv
        retention-days: 90