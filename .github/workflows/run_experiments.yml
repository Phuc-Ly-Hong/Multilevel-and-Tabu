name: Run Experiments with Comprehensive Results

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  compile:
    name: Compile C++
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y g++ bc
    
    - name: Compile executable
      run: |
        g++ -O2 -std=c++17 -o multilevel_tabu src/Multilevel_Tabu.cpp
        chmod +x multilevel_tabu
        ls -lh multilevel_tabu
    
    - name: Upload executable
      uses: actions/upload-artifact@v4
      with:
        name: multilevel-executable
        path: multilevel_tabu
        retention-days: 1

  run-small:
    name: Small ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 50
    
    strategy:
      fail-fast: false
      max-parallel: 12
      matrix:
        instance: [
          "10.5.1", "10.5.2", "10.5.3", "10.5.4",
          "10.10.1", "10.10.2", "10.10.3", "10.10.4",
          "10.20.1", "10.20.2", "10.20.3", "10.20.4",
          "20.5.1", "20.5.2", "20.5.3", "20.5.4",
          "20.10.1", "20.10.2", "20.10.3", "20.10.4",
          "20.20.1", "20.20.2", "20.20.3", "20.20.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance 5 times
      run: |
        chmod +x multilevel_tabu
        
        echo "üîÑ Running instance ${{ matrix.instance }} for 5 iterations..."
        
        for run in {1..5}; do
          echo ""
          echo "=========================================="
          echo "   RUN $run / 5"
          echo "=========================================="
          
          START_TIME=$(date +%s.%N)
          timeout 8m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output_run${run}.txt 2>&1 || true
          END_TIME=$(date +%s.%N)
          RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
          echo "$RUNTIME" > runtime_run${run}.txt
          
          echo "‚è±Ô∏è  Run $run completed in ${RUNTIME}s"
        done
        
        echo ""
        echo "‚úÖ All 5 runs completed!"
    
    - name: Parse and select best result
      run: |
        python3 <<'EOF'
        import re, json, os, glob
        instance = "${{ matrix.instance }}"
        
        def parse_output(output_file, runtime_file):
            """Parse m·ªôt output file v√† tr·∫£ v·ªÅ result dict"""
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_details = []
                
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                    
                    vehicle_pattern = re.compile(r'Vehicle (\d+):\s*(.+?)(?=Vehicle \d+:|Makespan:|$)', re.DOTALL)
                    for match in vehicle_pattern.finditer(solution_section):
                        vehicle_id = int(match.group(1))
                        vehicle_text = match.group(2)
                        
                        route_nodes = []
                        for token in vehicle_text.split():
                            if token.isdigit():
                                route_nodes.append(int(token))
                        
                        if len(route_nodes) >= 2:
                            vehicle_details.append({
                                "vehicle_id": vehicle_id,
                                "route": route_nodes,
                                "route_str": " -> ".join(map(str, route_nodes)),
                                "num_customers": len(route_nodes) - 2
                            })
                
                if makespan == 0.0 and fitness > 0.0: 
                    makespan = fitness
                
                return {
                    "instance": instance,
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "runtime_seconds": round(runtime, 3),
                    "feasible": (drone_viol < 0.01 and waiting_viol < 0.01),
                    "num_vehicles": len(vehicle_details),
                    "vehicles": vehicle_details
                }
            except Exception as e:
                return {"error": str(e), "fitness": float('inf')}
        
        # Parse t·∫•t c·∫£ 5 runs
        all_runs = []
        for run in range(1, 6):
            output_file = f"output_run{run}.txt"
            runtime_file = f"runtime_run{run}.txt"
            
            if os.path.exists(output_file):
                result = parse_output(output_file, runtime_file)
                result["run_number"] = run
                all_runs.append(result)
                
                status = '‚úÖ' if result.get('feasible', False) else '‚ö†Ô∏è'
                fitness = result.get('fitness', float('inf'))
                runtime = result.get('runtime_seconds', 0)
                print(f"{status} Run {run}: Fitness={fitness:.4f}, Runtime={runtime:.2f}s")
        
        # Ch·ªçn best run
        best_run = min(all_runs, key=lambda x: x.get('fitness', float('inf')))
        
        print(f"\nüèÜ BEST RUN: Run {best_run['run_number']}")
        print(f"   Fitness: {best_run['fitness']:.4f}")
        print(f"   Makespan: {best_run['makespan']:.4f}")
        print(f"   Feasible: {best_run['feasible']}")
        print(f"   Runtime: {best_run['runtime_seconds']:.2f}s")
        
        # L∆∞u results
        with open("result.json", "w") as f:
            json.dump(best_run, f, indent=2)
        
        with open("all_runs.json", "w") as f:
            json.dump(all_runs, f, indent=2)
        
        # Summary table
        print("\n" + "="*80)
        print(f"üìä SUMMARY FOR {instance}")
        print("="*80)
        print(f"{'Run':<6} {'Fitness':<12} {'Makespan':<12} {'Feasible':<10} {'Runtime':<10}")
        print("-"*80)
        
        for run_data in all_runs:
            run_num = run_data.get('run_number', 0)
            fitness = run_data.get('fitness', float('inf'))
            makespan = run_data.get('makespan', 0)
            feasible = 'YES' if run_data.get('feasible', False) else 'NO'
            runtime = run_data.get('runtime_seconds', 0)
            
            marker = 'üèÜ' if run_data == best_run else '  '
            print(f"{marker} {run_num:<4} {fitness:<12.4f} {makespan:<12.4f} {feasible:<10} {runtime:<10.2f}")
        
        print("="*80)
        
        # Statistics
        feasible_runs = [r for r in all_runs if r.get('feasible', False)]
        if feasible_runs:
            fitnesses = [r['fitness'] for r in feasible_runs]
            runtimes = [r['runtime_seconds'] for r in feasible_runs]
            
            print(f"\nüìà STATISTICS ({len(feasible_runs)}/5 feasible runs):")
            print(f"   Fitness:  Best={min(fitnesses):.4f}  Avg={sum(fitnesses)/len(fitnesses):.4f}  Worst={max(fitnesses):.4f}")
            print(f"   Runtime:  Best={min(runtimes):.2f}s  Avg={sum(runtimes)/len(runtimes):.2f}s  Worst={max(runtimes):.2f}s")
        
        EOF
    
    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          result.json
          all_runs.json
          output_run*.txt
        retention-days: 30

  run-medium:
    name: Medium ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 100
    
    strategy:
      fail-fast: false
      max-parallel: 8
      matrix:
        instance: [
          "50.10.1", "50.10.2", "50.10.3", "50.10.4",
          "50.20.1", "50.20.2", "50.20.3", "50.20.4",
          "50.30.1", "50.30.2", "50.30.3", "50.30.4",
          "50.40.1", "50.40.2", "50.40.3", "50.40.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance 5 times
      run: |
        chmod +x multilevel_tabu
        
        echo "üîÑ Running instance ${{ matrix.instance }} for 5 iterations..."
        
        for run in {1..5}; do
          echo ""
          echo "=========================================="
          echo "   RUN $run / 5"
          echo "=========================================="
          
          START_TIME=$(date +%s.%N)
          timeout 18m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output_run${run}.txt 2>&1 || true
          END_TIME=$(date +%s.%N)
          RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
          echo "$RUNTIME" > runtime_run${run}.txt
          
          echo "‚è±Ô∏è  Run $run completed in ${RUNTIME}s"
        done
        
        echo ""
        echo "‚úÖ All 5 runs completed!"
    
    - name: Parse and select best result
      run: |
        python3 <<'EOF'
        import re, json, os, glob
        instance = "${{ matrix.instance }}"
        
        def parse_output(output_file, runtime_file):
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_details = []
                
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                    
                    vehicle_pattern = re.compile(r'Vehicle (\d+):\s*(.+?)(?=Vehicle \d+:|Makespan:|$)', re.DOTALL)
                    for match in vehicle_pattern.finditer(solution_section):
                        vehicle_id = int(match.group(1))
                        vehicle_text = match.group(2)
                        
                        route_nodes = []
                        for token in vehicle_text.split():
                            if token.isdigit():
                                route_nodes.append(int(token))
                        
                        if len(route_nodes) >= 2:
                            vehicle_details.append({
                                "vehicle_id": vehicle_id,
                                "route": route_nodes,
                                "route_str": " -> ".join(map(str, route_nodes)),
                                "num_customers": len(route_nodes) - 2
                            })
                
                if makespan == 0.0 and fitness > 0.0: 
                    makespan = fitness
                
                return {
                    "instance": instance,
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "runtime_seconds": round(runtime, 3),
                    "feasible": (drone_viol < 0.01 and waiting_viol < 0.01),
                    "num_vehicles": len(vehicle_details),
                    "vehicles": vehicle_details
                }
            except Exception as e:
                return {"error": str(e), "fitness": float('inf')}
        
        all_runs = []
        for run in range(1, 6):
            result = parse_output(f"output_run{run}.txt", f"runtime_run{run}.txt")
            result["run_number"] = run
            all_runs.append(result)
            
            status = '‚úÖ' if result.get('feasible', False) else '‚ö†Ô∏è'
            print(f"{status} Run {run}: Fitness={result.get('fitness', float('inf')):.4f}")
        
        best_run = min(all_runs, key=lambda x: x.get('fitness', float('inf')))
        print(f"\nüèÜ BEST: Run {best_run['run_number']} - Fitness={best_run['fitness']:.4f}")
        
        with open("result.json", "w") as f:
            json.dump(best_run, f, indent=2)
        with open("all_runs.json", "w") as f:
            json.dump(all_runs, f, indent=2)
        EOF
    
    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          result.json
          all_runs.json
        retention-days: 30

  run-large:
    name: Large ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 200
    
    strategy:
      fail-fast: false
      max-parallel: 6
      matrix:
        instance: [
          "100.10.1", "100.10.2", "100.10.3", "100.10.4",
          "100.20.1", "100.20.2", "100.20.3", "100.20.4",
          "100.30.1", "100.30.2", "100.30.3", "100.30.4",
          "100.40.1", "100.40.2", "100.40.3", "100.40.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance 5 times
      run: |
        chmod +x multilevel_tabu
        
        echo "üîÑ Running instance ${{ matrix.instance }} for 5 iterations..."
        
        for run in {1..5}; do
          echo ""
          echo "=========================================="
          echo "   RUN $run / 5"
          echo "=========================================="
          
          START_TIME=$(date +%s.%N)
          timeout 35m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output_run${run}.txt 2>&1 || true
          END_TIME=$(date +%s.%N)
          RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
          echo "$RUNTIME" > runtime_run${run}.txt
          
          echo "‚è±Ô∏è  Run $run completed in ${RUNTIME}s"
        done
        
        echo ""
        echo "‚úÖ All 5 runs completed!"
    
    - name: Parse and select best result
      run: |
        python3 <<'EOF'
        import re, json, os
        instance = "${{ matrix.instance }}"
        
        def parse_output(output_file, runtime_file):
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_details = []
                
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                    
                    vehicle_pattern = re.compile(r'Vehicle (\d+):\s*(.+?)(?=Vehicle \d+:|Makespan:|$)', re.DOTALL)
                    for match in vehicle_pattern.finditer(solution_section):
                        vehicle_id = int(match.group(1))
                        vehicle_text = match.group(2)
                        
                        route_nodes = []
                        for token in vehicle_text.split():
                            if token.isdigit():
                                route_nodes.append(int(token))
                        
                        if len(route_nodes) >= 2:
                            vehicle_details.append({
                                "vehicle_id": vehicle_id,
                                "route": route_nodes,
                                "route_str": " -> ".join(map(str, route_nodes)),
                                "num_customers": len(route_nodes) - 2
                            })
                
                if makespan == 0.0 and fitness > 0.0: 
                    makespan = fitness
                
                return {
                    "instance": instance,
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "runtime_seconds": round(runtime, 3),
                    "feasible": (drone_viol < 0.01 and waiting_viol < 0.01),
                    "num_vehicles": len(vehicle_details),
                    "vehicles": vehicle_details
                }
            except Exception as e:
                return {"error": str(e), "fitness": float('inf')}
        
        all_runs = []
        for run in range(1, 6):
            result = parse_output(f"output_run{run}.txt", f"runtime_run{run}.txt")
            result["run_number"] = run
            all_runs.append(result)
            
            status = '‚úÖ' if result.get('feasible', False) else '‚ö†Ô∏è'
            print(f"{status} Run {run}: Fitness={result.get('fitness', float('inf')):.4f}")
        
        best_run = min(all_runs, key=lambda x: x.get('fitness', float('inf')))
        print(f"\nüèÜ BEST: Run {best_run['run_number']} - Fitness={best_run['fitness']:.4f}")
        
        with open("result.json", "w") as f:
            json.dump(best_run, f, indent=2)
        with open("all_runs.json", "w") as f:
            json.dump(all_runs, f, indent=2)
        EOF
    
    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          result.json
          all_runs.json
        retention-days: 30

  aggregate:
    name: Create Master CSV
    needs: [run-small, run-medium, run-large]
    runs-on: ubuntu-latest
    
    steps:
    - name: Download all results
      uses: actions/download-artifact@v4
      with:
        pattern: result-*
        merge-multiple: false
    
    - name: List downloaded files
      run: |
        echo "üìÅ Downloaded artifacts structure:"
        find . -name "*.json" -type f
        echo ""
        echo "üìÇ Directory structure:"
        ls -R
    
    - name: Create master comprehensive CSV
      run: |
        python3 <<'EOF'
        import json, glob, csv, os
        
        results = []
        
        print("üîç Searching for result.json files...")
        
        # T√¨m t·∫•t c·∫£ file result.json trong c√°c th∆∞ m·ª•c result-*
        for result_dir in glob.glob("result-*"):
            result_file = os.path.join(result_dir, "result.json")
            
            if os.path.exists(result_file):
                try:
                    with open(result_file) as f:
                        data = json.load(f)
                        if "error" not in data:
                            results.append(data)
                            print(f"  ‚úÖ Loaded: {result_file} - Instance: {data.get('instance', 'unknown')}")
                        else:
                            print(f"  ‚ö†Ô∏è  Skipped (has error): {result_file}")
                except Exception as e:
                    print(f"  ‚ùå Failed to parse: {result_file} - {e}")
        
        print(f"\nüìä Total valid results: {len(results)}")
        
        if len(results) == 0:
            print("‚ùå ERROR: No valid results found!")
            print("\nTrying alternative search method...")
            
            for result_file in glob.glob("**/result.json", recursive=True):
                print(f"  Found: {result_file}")
                try:
                    with open(result_file) as f:
                        data = json.load(f)
                        if "error" not in data and "instance" in data:
                            results.append(data)
                            print(f"    ‚úÖ Added: {data['instance']}")
                except:
                    pass
        
        if len(results) == 0:
            print("‚ùå FATAL: Still no results found! Creating empty CSV.")
            with open("MASTER_RESULTS.csv", "w") as f:
                f.write("Instance,Error\n")
                f.write("NO_RESULTS,No valid result files found\n")
            exit(0)
        
        # S·∫Øp x·∫øp theo instance
        results.sort(key=lambda x: (
            int(x["instance"].split(".")[0]),
            int(x["instance"].split(".")[1]),
            int(x["instance"].split(".")[2])
        ))
        
        print("\nüìã Instances in final CSV:")
        for idx, r in enumerate(results, 1):
            print(f"  {idx}. {r['instance']} - Run {r.get('run_number', '?')} - Fitness: {r.get('fitness', 0):.4f}")
        
        # T·∫°o CSV
        with open("MASTER_RESULTS.csv", "w", newline="", encoding="utf-8") as f:
            max_vehicles = max((r.get("num_vehicles", 0) for r in results), default=0)
            
            cols = [
                "Instance", "Instance_Size", "Num_Vehicles_Available", "Num_Customers",
                "Best_Run_Number", "Final_Fitness", "Final_Makespan", 
                "Total_Drone_Violation", "Total_Waiting_Violation",
                "Is_Feasible", "Runtime_Seconds", "Num_Vehicles_Used"
            ]
            
            for v in range(max_vehicles):
                cols.extend([f"V{v}_Route", f"V{v}_Num_Customers"])
            
            writer = csv.DictWriter(f, fieldnames=cols)
            writer.writeheader()
            
            for r in results:
                parts = r["instance"].split(".")
                
                row = {
                    "Instance": r["instance"],
                    "Instance_Size": int(parts[0]),
                    "Num_Vehicles_Available": int(parts[1]),
                    "Num_Customers": int(parts[0]),
                    "Best_Run_Number": r.get("run_number", 1),
                    "Final_Fitness": r.get("fitness", 0),
                    "Final_Makespan": r.get("makespan", 0),
                    "Total_Drone_Violation": r.get("drone_violation", 0),
                    "Total_Waiting_Violation": r.get("waiting_violation", 0),
                    "Is_Feasible": "YES" if r.get("feasible", False) else "NO",
                    "Runtime_Seconds": r.get("runtime_seconds", 0),
                    "Num_Vehicles_Used": r.get("num_vehicles", 0)
                }
                
                for v_idx, vehicle in enumerate(r.get("vehicles", [])):
                    if v_idx < max_vehicles:
                        row[f"V{v_idx}_Route"] = vehicle.get("route_str", "")
                        row[f"V{v_idx}_Num_Customers"] = vehicle.get("num_customers", 0)
                
                for v_idx in range(r.get("num_vehicles", 0), max_vehicles):
                    row[f"V{v_idx}_Route"] = ""
                    row[f"V{v_idx}_Num_Customers"] = 0
                
                writer.writerow(row)
        
        print(f"\n‚úÖ MASTER CSV CREATED: {len(results)} instances (best of 5 runs each)")
        
        # Statistics summary
        feasible_count = sum(1 for r in results if r.get("feasible", False))
        print(f"\nüìà FINAL SUMMARY:")
        print(f"   Total instances: {len(results)}")
        print(f"   Feasible solutions: {feasible_count} ({100*feasible_count/len(results):.1f}%)")
        print(f"   Infeasible: {len(results) - feasible_count}")
        
        if feasible_count > 0:
            feasible_results = [r for r in results if r.get("feasible", False)]
            avg_fitness = sum(r["fitness"] for r in feasible_results) / len(feasible_results)
            avg_runtime = sum(r["runtime_seconds"] for r in feasible_results) / len(feasible_results)
            
            print(f"\n   Average fitness (feasible): {avg_fitness:.4f}")
            print(f"   Average runtime (feasible): {avg_runtime:.2f}s")
        
        EOF
    
    - name: Verify CSV content
      run: |
        echo "üìÑ CSV Preview (first 10 lines):"
        head -10 MASTER_RESULTS.csv
        echo ""
        echo "üìä Total rows:"
        wc -l MASTER_RESULTS.csv
    
    - name: Upload master CSV
      uses: actions/upload-artifact@v4
      with:
        name: master-results
        path: MASTER_RESULTS.csv
        retention-days: 90
    
    - name: Create summary report
      run: |
        python3 <<'EOF'
        import csv
        
        with open("MASTER_RESULTS.csv", "r") as f:
            reader = csv.DictReader(f)
            rows = list(reader)
        
        print("\n" + "="*80)
        print("üìä EXPERIMENT SUMMARY REPORT")
        print("="*80)
        
        by_size = {}
        for row in rows:
            size = row["Instance_Size"]
            if size not in by_size:
                by_size[size] = {"total": 0, "feasible": 0, "avg_fitness": 0.0, "avg_runtime": 0.0}
            
            by_size[size]["total"] += 1
            if row["Is_Feasible"] == "YES":
                by_size[size]["feasible"] += 1
                by_size[size]["avg_fitness"] += float(row["Final_Fitness"])
                by_size[size]["avg_runtime"] += float(row["Runtime_Seconds"])
        
        for size in sorted(by_size.keys(), key=int):
            data = by_size[size]
            feasible = data["feasible"]
            total = data["total"]
            
            print(f"\nüì¶ Instance Size: {size}")
            print(f"   Total: {total} instances")
            print(f"   Feasible: {feasible}/{total} ({100*feasible/total:.1f}%)")
            
            if feasible > 0:
                avg_fit = data["avg_fitness"] / feasible
                avg_time = data["avg_runtime"] / feasible
                print(f"   Avg Fitness: {avg_fit:.4f}")
                print(f"   Avg Runtime: {avg_time:.2f}s")
        
        print("\n" + "="*80)
        EOF