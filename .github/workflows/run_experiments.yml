name: Run Experiments with Comprehensive Results

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  compile:
    name: Compile C++
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y g++ bc
    
    - name: Compile executable
      run: |
        g++ -O2 -std=c++17 -o multilevel_tabu src/Multilevel_Tabu.cpp
        chmod +x multilevel_tabu
        ls -lh multilevel_tabu
    
    - name: Upload executable
      uses: actions/upload-artifact@v4
      with:
        name: multilevel-executable
        path: multilevel_tabu
        retention-days: 1

  run-small:
    name: Small ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    strategy:
      fail-fast: false
      max-parallel: 12
      matrix:
        instance: [
          "10.5.1", "10.5.2", "10.5.3", "10.5.4",
          "10.10.1", "10.10.2", "10.10.3", "10.10.4",
          "10.20.1", "10.20.2", "10.20.3", "10.20.4",
          "20.5.1", "20.5.2", "20.5.3", "20.5.4",
          "20.10.1", "20.10.2", "20.10.3", "20.10.4",
          "20.20.1", "20.20.2", "20.20.3", "20.20.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance
      run: |
        chmod +x multilevel_tabu
        START_TIME=$(date +%s.%N)
        timeout 8m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output.txt 2>&1 || true
        END_TIME=$(date +%s.%N)
        RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
        echo "RUNTIME_SECONDS=$RUNTIME" >> runtime.txt
        echo "‚è±Ô∏è  Runtime: ${RUNTIME}s"
    
    - name: Parse comprehensive results
      run: |
        python3 <<'EOF'
        import re, json, os
        instance = "${{ matrix.instance }}"
        
        try:
            with open("output.txt", "r") as f:
                content = f.read()
            
            runtime = 0.0
            if os.path.exists("runtime.txt"):
                with open("runtime.txt", "r") as f:
                    for line in f:
                        if "RUNTIME_SECONDS=" in line:
                            runtime = float(line.split("=")[1].strip())
            
            last_route_idx = content.rfind("Route details:")
            makespan = drone_viol = waiting_viol = fitness = 0.0
            vehicle_details = []
            
            if last_route_idx != -1:
                solution_section = content[last_route_idx:]
                
                for line in solution_section.split('\n'):
                    if "Makespan:" in line:
                        m = re.search(r'Makespan:\s*([\d.]+)', line)
                        if m: makespan = float(m.group(1))
                    if "Drone violation:" in line:
                        m = re.search(r'Drone violation:\s*([\d.]+)', line)
                        if m: drone_viol = float(m.group(1))
                    if "Waiting violation:" in line:
                        m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                        if m: waiting_viol = float(m.group(1))
                    if "Fitness:" in line:
                        m = re.search(r'Fitness:\s*([\d.]+)', line)
                        if m: fitness = float(m.group(1))
                
                vehicle_pattern = re.compile(r'Vehicle (\d+):(.+?)(?=Vehicle \d+:|$)', re.DOTALL)
                for match in vehicle_pattern.finditer(solution_section):
                    vehicle_id = int(match.group(1))
                    vehicle_text = match.group(2)
                    
                    route_match = re.search(r'Route:\s*(.+?)(?=\n|$)', vehicle_text)
                    if route_match:
                        route_str = route_match.group(1).strip()
                        route_nodes = [int(x) for x in route_str.split() if x.isdigit()]
                        
                        veh_makespan = veh_drone_viol = veh_waiting_viol = 0.0
                        for line in vehicle_text.split('\n'):
                            if "Makespan:" in line:
                                m = re.search(r'Makespan:\s*([\d.]+)', line)
                                if m: veh_makespan = float(m.group(1))
                            if "Drone violation:" in line:
                                m = re.search(r'Drone violation:\s*([\d.]+)', line)
                                if m: veh_drone_viol = float(m.group(1))
                            if "Waiting violation:" in line:
                                m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                                if m: veh_waiting_viol = float(m.group(1))
                        
                        vehicle_details.append({
                            "vehicle_id": vehicle_id,
                            "route": route_nodes,
                            "route_str": " -> ".join(map(str, route_nodes)),
                            "makespan": round(veh_makespan, 4),
                            "drone_violation": round(veh_drone_viol, 4),
                            "waiting_violation": round(veh_waiting_viol, 4),
                            "num_customers": len(route_nodes) - 2
                        })
            
            if makespan == 0.0 and fitness > 0.0: makespan = fitness
            
            result = {
                "instance": instance,
                "makespan": round(makespan, 4),
                "drone_violation": round(drone_viol, 4),
                "waiting_violation": round(waiting_viol, 4),
                "fitness": round(fitness, 4),
                "runtime_seconds": round(runtime, 3),
                "feasible": (drone_viol < 0.01 and waiting_viol < 0.01),
                "num_vehicles": len(vehicle_details),
                "vehicles": vehicle_details
            }
            
            with open("result.json", "w") as f:
                json.dump(result, f, indent=2)
            
            status = '‚úÖ' if result['feasible'] else '‚ö†Ô∏è'
            print(f"{status} {instance} | Fitness: {fitness:.4f} | {len(vehicle_details)} vehicles | {runtime:.2f}s")
            
        except Exception as e:
            print(f"‚ùå {instance}: {e}")
            with open("result.json", "w") as f:
                json.dump({"instance": instance, "error": str(e)}, f)
        EOF
    
    - name: Upload result
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          result.json
          output.txt
        retention-days: 30

  run-medium:
    name: Medium ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    strategy:
      fail-fast: false
      max-parallel: 8
      matrix:
        instance: [
          "50.10.1", "50.10.2", "50.10.3", "50.10.4",
          "50.20.1", "50.20.2", "50.20.3", "50.20.4",
          "50.30.1", "50.30.2", "50.30.3", "50.30.4",
          "50.40.1", "50.40.2", "50.40.3", "50.40.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance
      run: |
        chmod +x multilevel_tabu
        START_TIME=$(date +%s.%N)
        timeout 18m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output.txt 2>&1 || true
        END_TIME=$(date +%s.%N)
        RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
        echo "RUNTIME_SECONDS=$RUNTIME" >> runtime.txt
    
    - name: Parse comprehensive results
      run: |
        python3 <<'EOF'
        import re, json, os
        instance = "${{ matrix.instance }}"
        
        try:
            with open("output.txt", "r") as f:
                content = f.read()
            
            runtime = 0.0
            if os.path.exists("runtime.txt"):
                with open("runtime.txt", "r") as f:
                    for line in f:
                        if "RUNTIME_SECONDS=" in line:
                            runtime = float(line.split("=")[1].strip())
            
            last_route_idx = content.rfind("Route details:")
            makespan = drone_viol = waiting_viol = fitness = 0.0
            vehicle_details = []
            
            if last_route_idx != -1:
                solution_section = content[last_route_idx:]
                
                for line in solution_section.split('\n'):
                    if "Makespan:" in line:
                        m = re.search(r'Makespan:\s*([\d.]+)', line)
                        if m: makespan = float(m.group(1))
                    if "Drone violation:" in line:
                        m = re.search(r'Drone violation:\s*([\d.]+)', line)
                        if m: drone_viol = float(m.group(1))
                    if "Waiting violation:" in line:
                        m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                        if m: waiting_viol = float(m.group(1))
                    if "Fitness:" in line:
                        m = re.search(r'Fitness:\s*([\d.]+)', line)
                        if m: fitness = float(m.group(1))
                
                vehicle_pattern = re.compile(r'Vehicle (\d+):(.+?)(?=Vehicle \d+:|$)', re.DOTALL)
                for match in vehicle_pattern.finditer(solution_section):
                    vehicle_id = int(match.group(1))
                    vehicle_text = match.group(2)
                    
                    route_match = re.search(r'Route:\s*(.+?)(?=\n|$)', vehicle_text)
                    if route_match:
                        route_str = route_match.group(1).strip()
                        route_nodes = [int(x) for x in route_str.split() if x.isdigit()]
                        
                        veh_makespan = veh_drone_viol = veh_waiting_viol = 0.0
                        for line in vehicle_text.split('\n'):
                            if "Makespan:" in line:
                                m = re.search(r'Makespan:\s*([\d.]+)', line)
                                if m: veh_makespan = float(m.group(1))
                            if "Drone violation:" in line:
                                m = re.search(r'Drone violation:\s*([\d.]+)', line)
                                if m: veh_drone_viol = float(m.group(1))
                            if "Waiting violation:" in line:
                                m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                                if m: veh_waiting_viol = float(m.group(1))
                        
                        vehicle_details.append({
                            "vehicle_id": vehicle_id,
                            "route": route_nodes,
                            "route_str": " -> ".join(map(str, route_nodes)),
                            "makespan": round(veh_makespan, 4),
                            "drone_violation": round(veh_drone_viol, 4),
                            "waiting_violation": round(veh_waiting_viol, 4),
                            "num_customers": len(route_nodes) - 2
                        })
            
            if makespan == 0.0 and fitness > 0.0: makespan = fitness
            
            result = {
                "instance": instance,
                "makespan": round(makespan, 4),
                "drone_violation": round(drone_viol, 4),
                "waiting_violation": round(waiting_viol, 4),
                "fitness": round(fitness, 4),
                "runtime_seconds": round(runtime, 3),
                "feasible": (drone_viol < 0.01 and waiting_viol < 0.01),
                "num_vehicles": len(vehicle_details),
                "vehicles": vehicle_details
            }
            
            with open("result.json", "w") as f:
                json.dump(result, f, indent=2)
            
            status = '‚úÖ' if result['feasible'] else '‚ö†Ô∏è'
            print(f"{status} {instance} | Fitness: {fitness:.4f}")
            
        except Exception as e:
            print(f"‚ùå {instance}: {e}")
            with open("result.json", "w") as f:
                json.dump({"instance": instance, "error": str(e)}, f)
        EOF
    
    - name: Upload result
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          result.json
          output.txt
        retention-days: 30

  run-large:
    name: Large ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 40
    
    strategy:
      fail-fast: false
      max-parallel: 6
      matrix:
        instance: [
          "100.10.1", "100.10.2", "100.10.3", "100.10.4",
          "100.20.1", "100.20.2", "100.20.3", "100.20.4",
          "100.30.1", "100.30.2", "100.30.3", "100.30.4",
          "100.40.1", "100.40.2", "100.40.3", "100.40.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance
      run: |
        chmod +x multilevel_tabu
        START_TIME=$(date +%s.%N)
        timeout 35m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output.txt 2>&1 || true
        END_TIME=$(date +%s.%N)
        RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
        echo "RUNTIME_SECONDS=$RUNTIME" >> runtime.txt
    
    - name: Parse comprehensive results
      run: |
        python3 <<'EOF'
        import re, json, os
        instance = "${{ matrix.instance }}"
        
        try:
            with open("output.txt", "r") as f:
                content = f.read()
            
            runtime = 0.0
            if os.path.exists("runtime.txt"):
                with open("runtime.txt", "r") as f:
                    for line in f:
                        if "RUNTIME_SECONDS=" in line:
                            runtime = float(line.split("=")[1].strip())
            
            last_route_idx = content.rfind("Route details:")
            makespan = drone_viol = waiting_viol = fitness = 0.0
            vehicle_details = []
            
            if last_route_idx != -1:
                solution_section = content[last_route_idx:]
                
                for line in solution_section.split('\n'):
                    if "Makespan:" in line:
                        m = re.search(r'Makespan:\s*([\d.]+)', line)
                        if m: makespan = float(m.group(1))
                    if "Drone violation:" in line:
                        m = re.search(r'Drone violation:\s*([\d.]+)', line)
                        if m: drone_viol = float(m.group(1))
                    if "Waiting violation:" in line:
                        m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                        if m: waiting_viol = float(m.group(1))
                    if "Fitness:" in line:
                        m = re.search(r'Fitness:\s*([\d.]+)', line)
                        if m: fitness = float(m.group(1))
                
                vehicle_pattern = re.compile(r'Vehicle (\d+):(.+?)(?=Vehicle \d+:|$)', re.DOTALL)
                for match in vehicle_pattern.finditer(solution_section):
                    vehicle_id = int(match.group(1))
                    vehicle_text = match.group(2)
                    
                    route_match = re.search(r'Route:\s*(.+?)(?=\n|$)', vehicle_text)
                    if route_match:
                        route_str = route_match.group(1).strip()
                        route_nodes = [int(x) for x in route_str.split() if x.isdigit()]
                        
                        veh_makespan = veh_drone_viol = veh_waiting_viol = 0.0
                        for line in vehicle_text.split('\n'):
                            if "Makespan:" in line:
                                m = re.search(r'Makespan:\s*([\d.]+)', line)
                                if m: veh_makespan = float(m.group(1))
                            if "Drone violation:" in line:
                                m = re.search(r'Drone violation:\s*([\d.]+)', line)
                                if m: veh_drone_viol = float(m.group(1))
                            if "Waiting violation:" in line:
                                m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                                if m: veh_waiting_viol = float(m.group(1))
                        
                        vehicle_details.append({
                            "vehicle_id": vehicle_id,
                            "route": route_nodes,
                            "route_str": " -> ".join(map(str, route_nodes)),
                            "makespan": round(veh_makespan, 4),
                            "drone_violation": round(veh_drone_viol, 4),
                            "waiting_violation": round(veh_waiting_viol, 4),
                            "num_customers": len(route_nodes) - 2
                        })
            
            if makespan == 0.0 and fitness > 0.0: makespan = fitness
            
            result = {
                "instance": instance,
                "makespan": round(makespan, 4),
                "drone_violation": round(drone_viol, 4),
                "waiting_violation": round(waiting_viol, 4),
                "fitness": round(fitness, 4),
                "runtime_seconds": round(runtime, 3),
                "feasible": (drone_viol < 0.01 and waiting_viol < 0.01),
                "num_vehicles": len(vehicle_details),
                "vehicles": vehicle_details
            }
            
            with open("result.json", "w") as f:
                json.dump(result, f, indent=2)
            
            status = '‚úÖ' if result['feasible'] else '‚ö†Ô∏è'
            print(f"{status} {instance} | Fitness: {fitness:.4f}")
            
        except Exception as e:
            print(f"‚ùå {instance}: {e}")
            with open("result.json", "w") as f:
                json.dump({"instance": instance, "error": str(e)}, f)
        EOF
    
    - name: Upload result
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          result.json
          output.txt
        retention-days: 30

  aggregate:
    name: Create Master CSV
    needs: [run-small, run-medium, run-large]
    runs-on: ubuntu-latest
    
    steps:
    - name: Download all results
      uses: actions/download-artifact@v4
      with:
        pattern: result-*
        merge-multiple: true
    
    - name: Create master comprehensive CSV
      run: |
        python3 <<'EOF'
        import json, glob, csv
        
        results = []
        for f in sorted(glob.glob("result*.json")):
            try:
                with open(f) as file:
                    data = json.load(file)
                    if "error" not in data:
                        results.append(data)
            except:
                pass
        
        results.sort(key=lambda x: (
            int(x["instance"].split(".")[0]),
            int(x["instance"].split(".")[1]),
            int(x["instance"].split(".")[2])
        ))
        
        # ========== MASTER CSV - T·∫§T C·∫¢ TH√îNG TIN TRONG 1 FILE ==========
        with open("MASTER_RESULTS.csv", "w", newline="", encoding="utf-8") as f:
            # T√¨m s·ªë xe t·ªëi ƒëa ƒë·ªÉ t·∫°o ƒë·ªß c·ªôt
            max_vehicles = max((r.get("num_vehicles", 0) for r in results), default=0)
            
            # T·∫°o header columns
            cols = [
                "Instance",
                "Instance_Size", 
                "Num_Vehicles_Available",
                "Num_Customers",
                "Final_Fitness",
                "Final_Makespan", 
                "Total_Drone_Violation",
                "Total_Waiting_Violation",
                "Is_Feasible",
                "Runtime_Seconds",
                "Num_Vehicles_Used",
                "Total_Customers_Served"
            ]
            
            # Th√™m c·ªôt cho t·ª´ng xe
            for v in range(max_vehicles):
                cols.extend([
                    f"V{v}_Route",
                    f"V{v}_Num_Customers",
                    f"V{v}_Makespan",
                    f"V{v}_Drone_Viol",
                    f"V{v}_Waiting_Viol",
                    f"V{v}_Is_Feasible"
                ])
            
            writer = csv.DictWriter(f, fieldnames=cols)
            writer.writeheader()
            
            for r in results:
                # Parse instance name (e.g., "10.5.1" -> size=10, vehicles=5, id=1)
                parts = r["instance"].split(".")
                size = int(parts[0])
                num_veh_avail = int(parts[1])
                
                row = {
                    "Instance": r["instance"],
                    "Instance_Size": size,
                    "Num_Vehicles_Available": num_veh_avail,
                    "Num_Customers": size,
                    "Final_Fitness": r.get("fitness", 0),
                    "Final_Makespan": r.get("makespan", 0),
                    "Total_Drone_Violation": r.get("drone_violation", 0),
                    "Total_Waiting_Violation": r.get("waiting_violation", 0),
                    "Is_Feasible": "YES" if r.get("feasible", False) else "NO",
                    "Runtime_Seconds": r.get("runtime_seconds", 0),
                    "Num_Vehicles_Used": r.get("num_vehicles", 0),
                    "Total_Customers_Served": sum(v.get("num_customers", 0) for v in r.get("vehicles", []))
                }
                
                # ƒêi·ªÅn th√¥ng tin t·ª´ng xe
                for v_idx, vehicle in enumerate(r.get("vehicles", [])):
                    if v_idx < max_vehicles:
                        v_feasible = (vehicle.get("drone_violation", 0) < 0.01 and 
                                     vehicle.get("waiting_violation", 0) < 0.01)
                        
                        row[f"V{v_idx}_Route"] = vehicle.get("route_str", "")
                        row[f"V{v_idx}_Num_Customers"] = vehicle.get("num_customers", 0)
                        row[f"V{v_idx}_Makespan"] = vehicle.get("makespan", 0)
                        row[f"V{v_idx}_Drone_Viol"] = vehicle.get("drone_violation", 0)
                        row[f"V{v_idx}_Waiting_Viol"] = vehicle.get("waiting_violation", 0)
                        row[f"V{v_idx}_Is_Feasible"] = "YES" if v_feasible else "NO"
                
                # ƒêi·ªÅn c√°c c·ªôt tr·ªëng cho xe kh√¥ng d√πng
                for v_idx in range(r.get("num_vehicles", 0), max_vehicles):
                    row[f"V{v_idx}_Route"] = ""
                    row[f"V{v_idx}_Num_Customers"] = 0
                    row[f"V{v_idx}_Makespan"] = 0
                    row[f"V{v_idx}_Drone_Viol"] = 0
                    row[f"V{v_idx}_Waiting_Viol"] = 0
                    row[f"V{v_idx}_Is_Feasible"] = ""
                
                writer.writerow(row)
        
        # ========== IN RA TH·ªêNG K√ä ==========
        print("\n" + "="*120)
        print("üìä COMPREHENSIVE EXPERIMENT RESULTS - MASTER CSV GENERATED")
        print("="*120)
        
        total = len(results)
        feasible = [r for r in results if r.get("feasible", False)]
        
        print(f"\nüéØ OVERALL: {len(feasible)}/{total} feasible ({len(feasible)/total*100:.1f}%)")
        
        for size in ["10", "20", "50", "100"]:
            size_results = [r for r in results if r["instance"].startswith(size + ".")]
            if size_results:
                size_feasible = [r for r in size_results if r.get("feasible", False)]
                print(f"\nüì¶ {size} customers: {len(size_feasible)}/{len(size_results)} feasible")
                
                if size_feasible:
                    fits = [r["fitness"] for r in size_feasible]
                    makes = [r["makespan"] for r in size_feasible]
                    times = [r["runtime_seconds"] for r in size_feasible]
                    vehs = [r["num_vehicles"] for r in size_feasible]
                    
                    print(f"   Fitness:  Best={min(fits):.4f}  Avg={sum(fits)/len(fits):.4f}  Worst={max(fits):.4f}")
                    print(f"   Makespan: Best={min(makes):.4f}  Avg={sum(makes)/len(makes):.4f}  Worst={max(makes):.4f}")
                    print(f"   Vehicles: Min={min(vehs)}  Avg={sum(vehs)/len(vehs):.1f}  Max={max(vehs)}")
                    print(f"   Runtime:  Best={min(times):.2f}s  Avg={sum(times)/len(times):.2f}s  Max={max(times):.2f}s")
        
        if feasible:
            print(f"\n{'='*120}")
            print("üèÜ BEST RESULTS ACROSS ALL INSTANCES:")
            print(f"{'='*120}")
            
            best_fitness = min(r["fitness"] for r in feasible)
            best_makespan = min(r["makespan"] for r in feasible)
            min_vehicles = min(r["num_vehicles"] for r in feasible)
            fastest = min(r["runtime_seconds"] for r in feasible)
            
            best_fit_inst = next(r for r in feasible if r["fitness"] == best_fitness)
            best_make_inst = next(r for r in feasible if r["makespan"] == best_makespan)
            min_veh_inst = next(r for r in feasible if r["num_vehicles"] == min_vehicles)
            fastest_inst = next(r for r in feasible if r["runtime_seconds"] == fastest)
            
            print(f"   Best Fitness:      {best_fitness:.4f}  (Instance: {best_fit_inst['instance']})")
            print(f"   Best Makespan:     {best_makespan:.4f}  (Instance: {best_make_inst['instance']})")
            print(f"   Fewest Vehicles:   {min_vehicles}  (Instance: {min_veh_inst['instance']})")
            print(f"   Fastest Runtime:   {fastest:.2f}s  (Instance: {fastest_inst['instance']})")
        
        print(f"\n{'='*120}")
        print(f"‚úÖ MASTER CSV CREATED: MASTER_RESULTS.csv")
        print(f"   Total Instances: {len(results)}")
        print(f"   Total Columns: {len(cols)}")
        print(f"   Max Vehicles per Instance: {max_vehicles}")
        print(f"   File contains: Instance info + Overall metrics + Per-vehicle details")
        print("="*120 + "\n")
        EOF
    
    - name: Upload master CSV
      uses: actions/upload-artifact@v4
      with:
        name: master-results
        path: MASTER_RESULTS.csv
        retention-days: 90