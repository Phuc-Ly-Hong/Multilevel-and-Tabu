name: Run Experiments with Detailed Results

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  compile:
    name: Compile C++
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y g++ bc
    
    - name: Compile executable
      run: |
        g++ -O2 -std=c++17 -o multilevel_tabu src/Multilevel_Tabu.cpp
        chmod +x multilevel_tabu
        ls -lh multilevel_tabu
    
    - name: Upload executable
      uses: actions/upload-artifact@v4
      with:
        name: multilevel-executable
        path: multilevel_tabu
        retention-days: 1

  run-small:
    name: Small ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 50
    
    strategy:
      fail-fast: false
      max-parallel: 12
      matrix:
        instance: [
          "10.5.1", "10.5.2", "10.5.3", "10.5.4",
          "10.10.1", "10.10.2", "10.10.3", "10.10.4",
          "10.20.1", "10.20.2", "10.20.3", "10.20.4",
          "20.5.1", "20.5.2", "20.5.3", "20.5.4",
          "20.10.1", "20.10.2", "20.10.3", "20.10.4",
          "20.20.1", "20.20.2", "20.20.3", "20.20.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance 5 times
      run: |
        chmod +x multilevel_tabu
        
        echo "üîÑ Running instance ${{ matrix.instance }} for 5 iterations..."
        
        for run in {1..5}; do
          echo ""
          echo "=========================================="
          echo "   RUN $run / 5"
          echo "=========================================="
          
          START_TIME=$(date +%s.%N)
          timeout 8m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output_run${run}.txt 2>&1 || true
          END_TIME=$(date +%s.%N)
          RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
          echo "$RUNTIME" > runtime_run${run}.txt
          
          echo "‚è±Ô∏è  Run $run completed in ${RUNTIME}s"
        done
        
        echo ""
        echo "‚úÖ All 5 runs completed!"
    
    - name: Parse and create detailed CSV
      run: |
        python3 <<'EOF'
        import re, json, os
        instance = "${{ matrix.instance }}"
        
        def parse_output(output_file, runtime_file):
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_routes = []
                
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                        
                        # Parse routes
                        if line.startswith("Vehicle "):
                            match = re.match(r'Vehicle (\d+):\s*(.+)', line)
                            if match:
                                vehicle_id = int(match.group(1))
                                route_str = match.group(2).strip()
                                vehicle_routes.append(f"V{vehicle_id}:{route_str}")
                
                return {
                    "runtime": round(runtime, 3),
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "feasible": "YES" if (drone_viol < 0.01 and waiting_viol < 0.01) else "NO",
                    "routes": " | ".join(vehicle_routes)
                }
            except Exception as e:
                return {
                    "runtime": 0, "makespan": 0, "drone_violation": 0,
                    "waiting_violation": 0, "fitness": float('inf'),
                    "feasible": "ERROR", "routes": f"Error: {e}"
                }
        
        # Parse all 5 runs
        all_runs = []
        for run in range(1, 6):
            result = parse_output(f"output_run{run}.txt", f"runtime_run{run}.txt")
            result["run"] = run
            all_runs.append(result)
            print(f"Run {run}: Fitness={result['fitness']}, Feasible={result['feasible']}")
        
        # Save to JSON
        with open("detailed_results.json", "w") as f:
            json.dump({
                "instance": instance,
                "runs": all_runs
            }, f, indent=2)
        
        print(f"‚úÖ Detailed results saved for {instance}")
        EOF
    
    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          detailed_results.json
          output_run*.txt
        retention-days: 30

  run-medium:
    name: Medium ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 100
    
    strategy:
      fail-fast: false
      max-parallel: 8
      matrix:
        instance: [
          "50.10.1", "50.10.2", "50.10.3", "50.10.4",
          "50.20.1", "50.20.2", "50.20.3", "50.20.4",
          "50.30.1", "50.30.2", "50.30.3", "50.30.4",
          "50.40.1", "50.40.2", "50.40.3", "50.40.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance 5 times
      run: |
        chmod +x multilevel_tabu
        
        for run in {1..5}; do
          START_TIME=$(date +%s.%N)
          timeout 18m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output_run${run}.txt 2>&1 || true
          END_TIME=$(date +%s.%N)
          RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
          echo "$RUNTIME" > runtime_run${run}.txt
        done
    
    - name: Parse and create detailed CSV
      run: |
        python3 <<'EOF'
        import re, json, os
        instance = "${{ matrix.instance }}"
        
        def parse_output(output_file, runtime_file):
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_routes = []
                
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                        
                        if line.startswith("Vehicle "):
                            match = re.match(r'Vehicle (\d+):\s*(.+)', line)
                            if match:
                                vehicle_routes.append(f"V{match.group(1)}:{match.group(2).strip()}")
                
                return {
                    "runtime": round(runtime, 3),
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "feasible": "YES" if (drone_viol < 0.01 and waiting_viol < 0.01) else "NO",
                    "routes": " | ".join(vehicle_routes)
                }
            except:
                return {"runtime": 0, "makespan": 0, "drone_violation": 0, "waiting_violation": 0, "fitness": float('inf'), "feasible": "ERROR", "routes": ""}
        
        all_runs = []
        for run in range(1, 6):
            result = parse_output(f"output_run{run}.txt", f"runtime_run{run}.txt")
            result["run"] = run
            all_runs.append(result)
        
        with open("detailed_results.json", "w") as f:
            json.dump({"instance": instance, "runs": all_runs}, f, indent=2)
        EOF
    
    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: detailed_results.json
        retention-days: 30

  run-large:
    name: Large ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 200
    
    strategy:
      fail-fast: false
      max-parallel: 6
      matrix:
        instance: [
          "100.10.1", "100.10.2", "100.10.3", "100.10.4",
          "100.20.1", "100.20.2", "100.20.3", "100.20.4",
          "100.30.1", "100.30.2", "100.30.3", "100.30.4",
          "100.40.1", "100.40.2", "100.40.3", "100.40.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance 5 times
      run: |
        chmod +x multilevel_tabu
        
        for run in {1..5}; do
          START_TIME=$(date +%s.%N)
          timeout 35m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output_run${run}.txt 2>&1 || true
          END_TIME=$(date +%s.%N)
          RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
          echo "$RUNTIME" > runtime_run${run}.txt
        done
    
    - name: Parse and create detailed CSV
      run: |
        python3 <<'EOF'
        import re, json, os
        instance = "${{ matrix.instance }}"
        
        def parse_output(output_file, runtime_file):
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_routes = []
                
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                        
                        if line.startswith("Vehicle "):
                            match = re.match(r'Vehicle (\d+):\s*(.+)', line)
                            if match:
                                vehicle_routes.append(f"V{match.group(1)}:{match.group(2).strip()}")
                
                return {
                    "runtime": round(runtime, 3),
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "feasible": "YES" if (drone_viol < 0.01 and waiting_viol < 0.01) else "NO",
                    "routes": " | ".join(vehicle_routes)
                }
            except:
                return {"runtime": 0, "makespan": 0, "drone_violation": 0, "waiting_violation": 0, "fitness": float('inf'), "feasible": "ERROR", "routes": ""}
        
        all_runs = []
        for run in range(1, 6):
            result = parse_output(f"output_run{run}.txt", f"runtime_run{run}.txt")
            result["run"] = run
            all_runs.append(result)
        
        with open("detailed_results.json", "w") as f:
            json.dump({"instance": instance, "runs": all_runs}, f, indent=2)
        EOF
    
    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: detailed_results.json
        retention-days: 30

  aggregate:
    name: Create Detailed Master CSV
    needs: [run-small, run-medium, run-large]
    runs-on: ubuntu-latest
    
    steps:
    - name: Download all results
      uses: actions/download-artifact@v4
      with:
        pattern: result-*
        merge-multiple: false
    
    - name: Create detailed CSV with routes
      run: |
        python3 <<'EOF'
        import json, glob, csv, os
        
        all_data = []
        
        for result_dir in glob.glob("result-*"):
            json_file = os.path.join(result_dir, "detailed_results.json")
            
            if os.path.exists(json_file):
                try:
                    with open(json_file) as f:
                        data = json.load(f)
                        all_data.append(data)
                except Exception as e:
                    print(f"‚ùå Failed: {json_file} - {e}")
        
        print(f"üìä Total instances: {len(all_data)}")
        
        # Sort
        all_data.sort(key=lambda x: tuple(int(p) for p in x["instance"].split(".")))
        
        # H√ÄM T√çNH S·ªê TECHNICIAN V√Ä DRONE THEO LOGIC TRONG MAIN()
        def calculate_vehicle_distribution(num_customers):
            """
            Logic t·ª´ main() c·ªßa Multilevel_Tabu.cpp:
            int customers = num_nodes-1;
            int pairs = 0;
            if (customers >= 6 && customers <= 12) pairs = 1;
            else if (customers <= 20) pairs = 2;
            else if (customers <= 50) pairs = 3;
            else if (customers <= 100) pairs = 4;
            
            for (int i = 0; i < pairs; ++i) {
                vehicles.push_back({ i+1, 0.58f, false, 0.0 }); // technician
            }
            for (int i = 0; i < pairs; ++i) {
                vehicles.push_back({ pairs + i + 1, 0.83f, true, 120.0 }); // drone
            }
            """
            customers = num_customers
            
            if 6 <= customers <= 12:
                pairs = 1
            elif customers <= 20:
                pairs = 2
            elif customers <= 50:
                pairs = 3
            elif customers <= 100:
                pairs = 4
            else:
                pairs = 0
            
            num_technician = pairs
            num_drone = pairs
            
            return num_technician, num_drone
        
        # Create CSV
        with open("DETAILED_RESULTS.csv", "w", newline="", encoding="utf-8") as f:
            cols = [
                "Instance", "Size", "Num_Technician", "Num_Drone", "Replica", "Run",
                "Runtime_s", "Makespan", "Drone_Violation", "Waiting_Violation",
                "Fitness", "Feasible", "Routes"
            ]
            
            writer = csv.DictWriter(f, fieldnames=cols)
            writer.writeheader()
            
            for data in all_data:
                parts = data["instance"].split(".")
                instance = data["instance"]
                size = int(parts[0])  # S·ªë l∆∞·ª£ng customers
                replica = int(parts[2])
                
                # ‚úÖ T√çNH S·ªê TECHNICIAN V√Ä DRONE THEO LOGIC C++
                num_technician, num_drone = calculate_vehicle_distribution(size)
                
                for run_data in data.get("runs", []):
                    row = {
                        "Instance": instance,
                        "Size": size,
                        "Num_Technician": num_technician,
                        "Num_Drone": num_drone,
                        "Replica": replica,
                        "Run": run_data["run"],
                        "Runtime_s": run_data["runtime"],
                        "Makespan": run_data["makespan"],
                        "Drone_Violation": run_data["drone_violation"],
                        "Waiting_Violation": run_data["waiting_violation"],
                        "Fitness": run_data["fitness"],
                        "Feasible": run_data["feasible"],
                        "Routes": run_data["routes"]
                    }
                    writer.writerow(row)
        
        print(f"‚úÖ DETAILED CSV created with {len(all_data) * 5} rows")
        
        # ‚úÖ IN RA V√ç D·ª§ ƒê·ªÇ KI·ªÇM TRA
        print("\nüìã Sample vehicle distribution:")
        for size in [10, 20, 50, 100]:
            tech, drone = calculate_vehicle_distribution(size)
            print(f"  {size} customers ‚Üí {tech} technician + {drone} drone = {tech + drone} total")
        EOF
    
    - name: Upload detailed CSV
      uses: actions/upload-artifact@v4
      with:
        name: detailed-master-results
        path: DETAILED_RESULTS.csv
        retention-days: 90