name: Run Experiments (Matrix - Fast)

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  compile:
    name: Compile C++
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y g++ bc
    
    - name: Compile executable
      run: |
        g++ -O2 -std=c++17 -o multilevel_tabu src/Multilevel_Tabu.cpp
        chmod +x multilevel_tabu
        ls -lh multilevel_tabu
    
    - name: Upload executable
      uses: actions/upload-artifact@v4
      with:
        name: multilevel-executable
        path: multilevel_tabu
        retention-days: 1

  run-small:
    name: Small ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    strategy:
      fail-fast: false
      max-parallel: 12
      matrix:
        instance: [
          "10.5.1", "10.5.2", "10.5.3", "10.5.4",
          "10.10.1", "10.10.2", "10.10.3", "10.10.4",
          "10.20.1", "10.20.2", "10.20.3", "10.20.4",
          "20.5.1", "20.5.2", "20.5.3", "20.5.4",
          "20.10.1", "20.10.2", "20.10.3", "20.10.4",
          "20.20.1", "20.20.2", "20.20.3", "20.20.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance
      run: |
        chmod +x multilevel_tabu
        START_TIME=$(date +%s.%N)
        timeout 8m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output.txt 2>&1 || true
        END_TIME=$(date +%s.%N)
        RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
        echo "RUNTIME_SECONDS=$RUNTIME" >> runtime.txt
        echo "‚è±Ô∏è  Runtime: ${RUNTIME}s"
    
    - name: Parse results
      run: |
        python3 <<'EOF'
        import re, json, os
        instance = "${{ matrix.instance }}"
        try:
            with open("output.txt", "r") as f:
                content = f.read()
            runtime = 0.0
            if os.path.exists("runtime.txt"):
                with open("runtime.txt", "r") as f:
                    for line in f:
                        if "RUNTIME_SECONDS=" in line:
                            runtime = float(line.split("=")[1].strip())
            last_route_idx = content.rfind("Route details:")
            makespan = drone_viol = waiting_viol = fitness = 0.0
            if last_route_idx != -1:
                for line in content[last_route_idx:].split('\n'):
                    if "Makespan:" in line:
                        m = re.search(r'Makespan:\s*([\d.]+)', line)
                        if m: makespan = float(m.group(1))
                    if "Drone violation:" in line:
                        m = re.search(r'Drone violation:\s*([\d.]+)', line)
                        if m: drone_viol = float(m.group(1))
                    if "Waiting violation:" in line:
                        m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                        if m: waiting_viol = float(m.group(1))
                    if "Fitness:" in line:
                        m = re.search(r'Fitness:\s*([\d.]+)', line)
                        if m: fitness = float(m.group(1))
            if makespan == 0.0 and fitness > 0.0: makespan = fitness
            result = {"instance": instance, "makespan": round(makespan,4), "drone_violation": round(drone_viol,4), "waiting_violation": round(waiting_viol,4), "fitness": round(fitness,4), "runtime_seconds": round(runtime,3), "feasible": (drone_viol < 0.01 and waiting_viol < 0.01)}
            with open("result.json", "w") as f: json.dump(result, f, indent=2)
            print(f"{'‚úÖ' if result['feasible'] else '‚ö†Ô∏è'} {instance} | M:{makespan:.2f} F:{fitness:.2f} T:{runtime:.2f}s")
        except Exception as e:
            print(f"‚ùå {instance}: {e}")
            with open("result.json", "w") as f: json.dump({"instance": instance, "error": str(e)}, f)
        EOF
    
    - name: Upload result
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          result.json
          output.txt
        retention-days: 30

  run-medium:
    name: Medium ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    strategy:
      fail-fast: false
      max-parallel: 8
      matrix:
        instance: [
          "50.10.1", "50.10.2", "50.10.3", "50.10.4",
          "50.20.1", "50.20.2", "50.20.3", "50.20.4",
          "50.30.1", "50.30.2", "50.30.3", "50.30.4",
          "50.40.1", "50.40.2", "50.40.3", "50.40.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance
      run: |
        chmod +x multilevel_tabu
        START_TIME=$(date +%s.%N)
        timeout 18m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output.txt 2>&1 || true
        END_TIME=$(date +%s.%N)
        RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
        echo "RUNTIME_SECONDS=$RUNTIME" >> runtime.txt
        echo "‚è±Ô∏è  Runtime: ${RUNTIME}s"
    
    - name: Parse results
      run: |
        python3 <<'EOF'
        import re, json, os
        instance = "${{ matrix.instance }}"
        try:
            with open("output.txt", "r") as f:
                content = f.read()
            runtime = 0.0
            if os.path.exists("runtime.txt"):
                with open("runtime.txt", "r") as f:
                    for line in f:
                        if "RUNTIME_SECONDS=" in line:
                            runtime = float(line.split("=")[1].strip())
            last_route_idx = content.rfind("Route details:")
            makespan = drone_viol = waiting_viol = fitness = 0.0
            if last_route_idx != -1:
                for line in content[last_route_idx:].split('\n'):
                    if "Makespan:" in line:
                        m = re.search(r'Makespan:\s*([\d.]+)', line)
                        if m: makespan = float(m.group(1))
                    if "Drone violation:" in line:
                        m = re.search(r'Drone violation:\s*([\d.]+)', line)
                        if m: drone_viol = float(m.group(1))
                    if "Waiting violation:" in line:
                        m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                        if m: waiting_viol = float(m.group(1))
                    if "Fitness:" in line:
                        m = re.search(r'Fitness:\s*([\d.]+)', line)
                        if m: fitness = float(m.group(1))
            if makespan == 0.0 and fitness > 0.0: makespan = fitness
            result = {"instance": instance, "makespan": round(makespan,4), "drone_violation": round(drone_viol,4), "waiting_violation": round(waiting_viol,4), "fitness": round(fitness,4), "runtime_seconds": round(runtime,3), "feasible": (drone_viol < 0.01 and waiting_viol < 0.01)}
            with open("result.json", "w") as f: json.dump(result, f, indent=2)
            print(f"{'‚úÖ' if result['feasible'] else '‚ö†Ô∏è'} {instance} | M:{makespan:.2f} F:{fitness:.2f} T:{runtime:.2f}s")
        except Exception as e:
            print(f"‚ùå {instance}: {e}")
            with open("result.json", "w") as f: json.dump({"instance": instance, "error": str(e)}, f)
        EOF
    
    - name: Upload result
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          result.json
          output.txt
        retention-days: 30

  run-large:
    name: Large ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 40
    
    strategy:
      fail-fast: false
      max-parallel: 6
      matrix:
        instance: [
          "100.10.1", "100.10.2", "100.10.3", "100.10.4",
          "100.20.1", "100.20.2", "100.20.3", "100.20.4",
          "100.30.1", "100.30.2", "100.30.3", "100.30.4",
          "100.40.1", "100.40.2", "100.40.3", "100.40.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance
      run: |
        chmod +x multilevel_tabu
        START_TIME=$(date +%s.%N)
        timeout 35m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output.txt 2>&1 || true
        END_TIME=$(date +%s.%N)
        RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
        echo "RUNTIME_SECONDS=$RUNTIME" >> runtime.txt
        echo "‚è±Ô∏è  Runtime: ${RUNTIME}s"
    
    - name: Parse results
      run: |
        python3 <<'EOF'
        import re, json, os
        instance = "${{ matrix.instance }}"
        try:
            with open("output.txt", "r") as f:
                content = f.read()
            runtime = 0.0
            if os.path.exists("runtime.txt"):
                with open("runtime.txt", "r") as f:
                    for line in f:
                        if "RUNTIME_SECONDS=" in line:
                            runtime = float(line.split("=")[1].strip())
            last_route_idx = content.rfind("Route details:")
            makespan = drone_viol = waiting_viol = fitness = 0.0
            if last_route_idx != -1:
                for line in content[last_route_idx:].split('\n'):
                    if "Makespan:" in line:
                        m = re.search(r'Makespan:\s*([\d.]+)', line)
                        if m: makespan = float(m.group(1))
                    if "Drone violation:" in line:
                        m = re.search(r'Drone violation:\s*([\d.]+)', line)
                        if m: drone_viol = float(m.group(1))
                    if "Waiting violation:" in line:
                        m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                        if m: waiting_viol = float(m.group(1))
                    if "Fitness:" in line:
                        m = re.search(r'Fitness:\s*([\d.]+)', line)
                        if m: fitness = float(m.group(1))
            if makespan == 0.0 and fitness > 0.0: makespan = fitness
            result = {"instance": instance, "makespan": round(makespan,4), "drone_violation": round(drone_viol,4), "waiting_violation": round(waiting_viol,4), "fitness": round(fitness,4), "runtime_seconds": round(runtime,3), "feasible": (drone_viol < 0.01 and waiting_viol < 0.01)}
            with open("result.json", "w") as f: json.dump(result, f, indent=2)
            print(f"{'‚úÖ' if result['feasible'] else '‚ö†Ô∏è'} {instance} | M:{makespan:.2f} F:{fitness:.2f} T:{runtime:.2f}s")
        except Exception as e:
            print(f"‚ùå {instance}: {e}")
            with open("result.json", "w") as f: json.dump({"instance": instance, "error": str(e)}, f)
        EOF
    
    - name: Upload result
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          result.json
          output.txt
        retention-days: 30

  aggregate:
    name: Aggregate Results
    needs: [run-small, run-medium, run-large]
    runs-on: ubuntu-latest
    
    steps:
    - name: Download all results
      uses: actions/download-artifact@v4
      with:
        pattern: result-*
        merge-multiple: true
    
    - name: Create summary
      run: |
        python3 <<'EOF'
        import json, glob, csv
        results = []
        for f in sorted(glob.glob("result.json")):
            try:
                with open(f) as file: results.append(json.load(file))
            except: pass
        results.sort(key=lambda x: x.get("instance", ""))
        with open("all_results.csv", "w", newline="") as f:
            writer = csv.DictWriter(f, fieldnames=["instance", "fitness", "makespan", "drone_violation", "waiting_violation", "runtime_seconds", "feasible"])
            writer.writeheader()
            for r in results:
                if "error" not in r:
                    writer.writerow({"instance": r.get("instance"), "fitness": r.get("fitness", 0), "makespan": r.get("makespan", 0), "drone_violation": r.get("drone_violation", 0), "waiting_violation": r.get("waiting_violation", 0), "runtime_seconds": r.get("runtime_seconds", 0), "feasible": r.get("feasible", False)})
        print("\n" + "="*80 + "\nüìä EXPERIMENT SUMMARY\n" + "="*80)
        for size in ["10", "20", "50", "100"]:
            size_results = [r for r in results if r.get("instance", "").startswith(size + ".") and "error" not in r]
            if size_results:
                feasible = [r for r in size_results if r.get("feasible", False)]
                print(f"\nüì¶ {size} nodes: {len(feasible)}/{len(size_results)} feasible ({len(feasible)/len(size_results)*100:.1f}%)")
                if feasible:
                    fits = [r["fitness"] for r in feasible]
                    times = [r.get("runtime_seconds", 0) for r in feasible]
                    print(f"   Fitness  ‚Üí Best: {min(fits):.4f} | Avg: {sum(fits)/len(fits):.4f} | Worst: {max(fits):.4f}")
                    print(f"   Runtime  ‚Üí Best: {min(times):.2f}s | Avg: {sum(times)/len(times):.2f}s | Worst: {max(times):.2f}s")
        total = len([r for r in results if "error" not in r])
        feasible_all = [r for r in results if r.get("feasible", False)]
        print(f"\nüéØ OVERALL: {len(feasible_all)}/{total} feasible ({len(feasible_all)/total*100:.1f}%)")
        if feasible_all:
            fits = [r["fitness"] for r in feasible_all]
            times = [r.get("runtime_seconds", 0) for r in feasible_all]
            print(f"   üèÜ Best fitness: {min(fits):.4f}\n   üìä Avg fitness: {sum(fits)/len(fits):.4f}\n   üìâ Worst fitness: {max(fits):.4f}")
            print(f"\n   ‚è±Ô∏è  Best runtime: {min(times):.2f}s\n   ‚è±Ô∏è  Avg runtime: {sum(times)/len(times):.2f}s\n   ‚è±Ô∏è  Worst runtime: {max(times):.2f}s\n   ‚è±Ô∏è  Total runtime: {sum(times):.2f}s")
        print("="*80 + "\n")
        EOF
    
    - name: Upload final results
      uses: actions/upload-artifact@v4
      with:
        name: all-results
        path: all_results.csv
        retention-days: 90