name: Run Experiments with Comprehensive Results

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  compile:
    name: Compile C++
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y g++ bc
    
    - name: Compile executable
      run: |
        g++ -O2 -std=c++17 -o multilevel_tabu src/Multilevel_Tabu.cpp
        chmod +x multilevel_tabu
        ls -lh multilevel_tabu
    
    - name: Upload executable
      uses: actions/upload-artifact@v4
      with:
        name: multilevel-executable
        path: multilevel_tabu
        retention-days: 1

  run-small:
    name: Small ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 50
    
    strategy:
      fail-fast: false
      max-parallel: 12
      matrix:
        instance: [
          "10.5.1", "10.5.2", "10.5.3", "10.5.4",
          "10.10.1", "10.10.2", "10.10.3", "10.10.4",
          "10.20.1", "10.20.2", "10.20.3", "10.20.4",
          "20.5.1", "20.5.2", "20.5.3", "20.5.4",
          "20.10.1", "20.10.2", "20.10.3", "20.10.4",
          "20.20.1", "20.20.2", "20.20.3", "20.20.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance 5 times
      run: |
        chmod +x multilevel_tabu
        
        echo "üîÑ Running instance ${{ matrix.instance }} for 5 iterations..."
        
        for run in {1..5}; do
          echo ""
          echo "=========================================="
          echo "   RUN $run / 5"
          echo "=========================================="
          
          START_TIME=$(date +%s.%N)
          timeout 8m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output_run${run}.txt 2>&1 || true
          END_TIME=$(date +%s.%N)
          RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
          echo "$RUNTIME" > runtime_run${run}.txt
          
          echo "‚è±Ô∏è  Run $run completed in ${RUNTIME}s"
        done
        
        echo ""
        echo "‚úÖ All 5 runs completed!"
    
    - name: Parse and aggregate ALL 5 runs
      run: |
        python3 <<'EOF'
        import re, json, os, statistics
        instance = "${{ matrix.instance }}"
        
        def parse_output(output_file, runtime_file):
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_details = []
                
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                    
                    vehicle_pattern = re.compile(r'Vehicle (\d+):\s*(.+?)(?=Vehicle \d+:|Makespan:|$)', re.DOTALL)
                    for match in vehicle_pattern.finditer(solution_section):
                        vehicle_id = int(match.group(1))
                        vehicle_text = match.group(2)
                        
                        route_nodes = []
                        for token in vehicle_text.split():
                            if token.isdigit():
                                route_nodes.append(int(token))
                        
                        if len(route_nodes) >= 2:
                            vehicle_details.append({
                                "vehicle_id": vehicle_id,
                                "route": route_nodes,
                                "route_str": " -> ".join(map(str, route_nodes)),
                                "num_customers": len(route_nodes) - 2
                            })
                
                if makespan == 0.0 and fitness > 0.0: 
                    makespan = fitness
                
                return {
                    "instance": instance,
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "runtime_seconds": round(runtime, 3),
                    "feasible": (drone_viol < 0.01 and waiting_viol < 0.01),
                    "num_vehicles": len(vehicle_details),
                    "vehicles": vehicle_details
                }
            except Exception as e:
                return {"error": str(e), "fitness": float('inf'), "feasible": False}
        
        # ‚úÖ L·∫§Y T·∫§T C·∫¢ 5 RUNS
        all_runs = []
        for run in range(1, 6):
            output_file = f"output_run{run}.txt"
            runtime_file = f"runtime_run{run}.txt"
            
            if os.path.exists(output_file):
                result = parse_output(output_file, runtime_file)
                result["run_number"] = run
                all_runs.append(result)
                
                status = '‚úÖ' if result.get('feasible', False) else '‚ö†Ô∏è'
                fitness = result.get('fitness', float('inf'))
                runtime = result.get('runtime_seconds', 0)
                print(f"{status} Run {run}: Fitness={fitness:.4f}, Runtime={runtime:.2f}s, Feasible={result.get('feasible')}")
        
        # Ph√¢n lo·∫°i
        feasible_runs = [r for r in all_runs if r.get('feasible', False)]
        infeasible_runs = [r for r in all_runs if not r.get('feasible', False)]
        
        print(f"\nüìä Total: {len(all_runs)}, Feasible: {len(feasible_runs)}, Infeasible: {len(infeasible_runs)}")
        
        # T√≠nh to√°n cho T·∫§T C·∫¢ runs
        all_fitnesses = [r['fitness'] for r in all_runs if r['fitness'] != float('inf')]
        all_makespans = [r['makespan'] for r in all_runs if r.get('makespan', 0) > 0]
        all_runtimes = [r['runtime_seconds'] for r in all_runs]
        
        # Best overall
        best_run_overall = min(all_runs, key=lambda x: x.get('fitness', float('inf'))) if all_runs else None
        worst_run_overall = max(all_runs, key=lambda x: x.get('fitness', 0)) if all_runs else None
        best_feasible_run = min(feasible_runs, key=lambda x: x.get('fitness', float('inf'))) if feasible_runs else None
        
        # Summary
        summary = {
            "instance": instance,
            "total_runs": len(all_runs),
            "feasible_runs": len(feasible_runs),
            "infeasible_runs": len(infeasible_runs),
            "has_feasible": len(feasible_runs) > 0,
            
            "all_runs_stats": {
                "avg_fitness": round(statistics.mean(all_fitnesses), 4) if all_fitnesses else None,
                "std_fitness": round(statistics.stdev(all_fitnesses), 4) if len(all_fitnesses) > 1 else 0.0,
                "min_fitness": round(min(all_fitnesses), 4) if all_fitnesses else None,
                "max_fitness": round(max(all_fitnesses), 4) if all_fitnesses else None,
                "avg_makespan": round(statistics.mean(all_makespans), 4) if all_makespans else None,
                "avg_runtime": round(statistics.mean(all_runtimes), 3) if all_runtimes else None,
            },
            
            "best_run_overall": best_run_overall,
            "worst_run_overall": worst_run_overall,
            "best_feasible_run": best_feasible_run,
            "all_runs_details": all_runs
        }
        
        if best_run_overall:
            print(f"\nüèÜ BEST OVERALL: Run {best_run_overall['run_number']} - Fitness={best_run_overall['fitness']:.4f}")
        if best_feasible_run:
            print(f"‚úÖ BEST FEASIBLE: Run {best_feasible_run['run_number']} - Fitness={best_feasible_run['fitness']:.4f}")
        
        with open("summary.json", "w") as f:
            json.dump(summary, f, indent=2)
        
        with open("all_runs.json", "w") as f:
            json.dump(all_runs, f, indent=2)
        
        EOF
    
    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          summary.json
          all_runs.json
          output_run*.txt
        retention-days: 30

  run-medium:
    name: Medium ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 100
    
    strategy:
      fail-fast: false
      max-parallel: 8
      matrix:
        instance: [
          "50.10.1", "50.10.2", "50.10.3", "50.10.4",
          "50.20.1", "50.20.2", "50.20.3", "50.20.4",
          "50.30.1", "50.30.2", "50.30.3", "50.30.4",
          "50.40.1", "50.40.2", "50.40.3", "50.40.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance 5 times
      run: |
        chmod +x multilevel_tabu
        
        echo "üîÑ Running instance ${{ matrix.instance }} for 5 iterations..."
        
        for run in {1..5}; do
          echo ""
          echo "=========================================="
          echo "   RUN $run / 5"
          echo "=========================================="
          
          START_TIME=$(date +%s.%N)
          timeout 18m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output_run${run}.txt 2>&1 || true
          END_TIME=$(date +%s.%N)
          RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
          echo "$RUNTIME" > runtime_run${run}.txt
          
          echo "‚è±Ô∏è  Run $run completed in ${RUNTIME}s"
        done
        
        echo ""
        echo "‚úÖ All 5 runs completed!"
    
    - name: Parse and aggregate ALL 5 runs
      run: |
        python3 <<'EOF'
        import re, json, os, statistics
        instance = "${{ matrix.instance }}"
        
        def parse_output(output_file, runtime_file):
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_details = []
                
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                    
                    vehicle_pattern = re.compile(r'Vehicle (\d+):\s*(.+?)(?=Vehicle \d+:|Makespan:|$)', re.DOTALL)
                    for match in vehicle_pattern.finditer(solution_section):
                        vehicle_id = int(match.group(1))
                        vehicle_text = match.group(2)
                        
                        route_nodes = []
                        for token in vehicle_text.split():
                            if token.isdigit():
                                route_nodes.append(int(token))
                        
                        if len(route_nodes) >= 2:
                            vehicle_details.append({
                                "vehicle_id": vehicle_id,
                                "route": route_nodes,
                                "route_str": " -> ".join(map(str, route_nodes)),
                                "num_customers": len(route_nodes) - 2
                            })
                
                if makespan == 0.0 and fitness > 0.0: 
                    makespan = fitness
                
                return {
                    "instance": instance,
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "runtime_seconds": round(runtime, 3),
                    "feasible": (drone_viol < 0.01 and waiting_viol < 0.01),
                    "num_vehicles": len(vehicle_details),
                    "vehicles": vehicle_details
                }
            except Exception as e:
                return {"error": str(e), "fitness": float('inf'), "feasible": False}
        
        all_runs = []
        for run in range(1, 6):
            result = parse_output(f"output_run{run}.txt", f"runtime_run{run}.txt")
            result["run_number"] = run
            all_runs.append(result)
            
            status = '‚úÖ' if result.get('feasible', False) else '‚ö†Ô∏è'
            print(f"{status} Run {run}: Fitness={result.get('fitness', float('inf')):.4f}")
        
        feasible_runs = [r for r in all_runs if r.get('feasible', False)]
        all_fitnesses = [r['fitness'] for r in all_runs if r['fitness'] != float('inf')]
        all_makespans = [r['makespan'] for r in all_runs if r.get('makespan', 0) > 0]
        all_runtimes = [r['runtime_seconds'] for r in all_runs]
        
        best_run_overall = min(all_runs, key=lambda x: x.get('fitness', float('inf'))) if all_runs else None
        best_feasible = min(feasible_runs, key=lambda x: x.get('fitness', float('inf'))) if feasible_runs else None
        
        summary = {
            "instance": instance,
            "total_runs": len(all_runs),
            "feasible_runs": len(feasible_runs),
            "infeasible_runs": len(all_runs) - len(feasible_runs),
            "has_feasible": len(feasible_runs) > 0,
            "all_runs_stats": {
                "avg_fitness": round(statistics.mean(all_fitnesses), 4) if all_fitnesses else None,
                "std_fitness": round(statistics.stdev(all_fitnesses), 4) if len(all_fitnesses) > 1 else 0.0,
                "min_fitness": round(min(all_fitnesses), 4) if all_fitnesses else None,
                "max_fitness": round(max(all_fitnesses), 4) if all_fitnesses else None,
                "avg_makespan": round(statistics.mean(all_makespans), 4) if all_makespans else None,
                "avg_runtime": round(statistics.mean(all_runtimes), 3) if all_runtimes else None,
            },
            "best_run_overall": best_run_overall,
            "best_feasible_run": best_feasible,
            "all_runs_details": all_runs
        }
        
        print(f"\nüèÜ BEST: Run {best_run_overall['run_number'] if best_run_overall else 'N/A'}")
        
        with open("summary.json", "w") as f:
            json.dump(summary, f, indent=2)
        with open("all_runs.json", "w") as f:
            json.dump(all_runs, f, indent=2)
        EOF
    
    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          summary.json
          all_runs.json
        retention-days: 30

  run-large:
    name: Large ${{ matrix.instance }}
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 200
    
    strategy:
      fail-fast: false
      max-parallel: 6
      matrix:
        instance: [
          "100.10.1", "100.10.2", "100.10.3", "100.10.4",
          "100.20.1", "100.20.2", "100.20.3", "100.20.4",
          "100.30.1", "100.30.2", "100.30.3", "100.30.4",
          "100.40.1", "100.40.2", "100.40.3", "100.40.4"
        ]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable
    
    - name: Run instance 5 times
      run: |
        chmod +x multilevel_tabu
        
        echo "üîÑ Running instance ${{ matrix.instance }} for 5 iterations..."
        
        for run in {1..5}; do
          echo ""
          echo "=========================================="
          echo "   RUN $run / 5"
          echo "=========================================="
          
          START_TIME=$(date +%s.%N)
          timeout 35m ./multilevel_tabu instances/${{ matrix.instance }}.txt > output_run${run}.txt 2>&1 || true
          END_TIME=$(date +%s.%N)
          RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
          echo "$RUNTIME" > runtime_run${run}.txt
          
          echo "‚è±Ô∏è  Run $run completed in ${RUNTIME}s"
        done
        
        echo ""
        echo "‚úÖ All 5 runs completed!"
    
    - name: Parse and aggregate ALL 5 runs
      run: |
        python3 <<'EOF'
        import re, json, os, statistics
        instance = "${{ matrix.instance }}"
        
        def parse_output(output_file, runtime_file):
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_details = []
                
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                    
                    vehicle_pattern = re.compile(r'Vehicle (\d+):\s*(.+?)(?=Vehicle \d+:|Makespan:|$)', re.DOTALL)
                    for match in vehicle_pattern.finditer(solution_section):
                        vehicle_id = int(match.group(1))
                        vehicle_text = match.group(2)
                        
                        route_nodes = []
                        for token in vehicle_text.split():
                            if token.isdigit():
                                route_nodes.append(int(token))
                        
                        if len(route_nodes) >= 2:
                            vehicle_details.append({
                                "vehicle_id": vehicle_id,
                                "route": route_nodes,
                                "route_str": " -> ".join(map(str, route_nodes)),
                                "num_customers": len(route_nodes) - 2
                            })
                
                if makespan == 0.0 and fitness > 0.0: 
                    makespan = fitness
                
                return {
                    "instance": instance,
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "runtime_seconds": round(runtime, 3),
                    "feasible": (drone_viol < 0.01 and waiting_viol < 0.01),
                    "num_vehicles": len(vehicle_details),
                    "vehicles": vehicle_details
                }
            except Exception as e:
                return {"error": str(e), "fitness": float('inf'), "feasible": False}
        
        all_runs = []
        for run in range(1, 6):
            result = parse_output(f"output_run{run}.txt", f"runtime_run{run}.txt")
            result["run_number"] = run
            all_runs.append(result)
            
            status = '‚úÖ' if result.get('feasible', False) else '‚ö†Ô∏è'
            print(f"{status} Run {run}: Fitness={result.get('fitness', float('inf')):.4f}")
        
        feasible_runs = [r for r in all_runs if r.get('feasible', False)]
        all_fitnesses = [r['fitness'] for r in all_runs if r['fitness'] != float('inf')]
        all_makespans = [r['makespan'] for r in all_runs if r.get('makespan', 0) > 0]
        all_runtimes = [r['runtime_seconds'] for r in all_runs]
        
        best_run_overall = min(all_runs, key=lambda x: x.get('fitness', float('inf'))) if all_runs else None
        best_feasible = min(feasible_runs, key=lambda x: x.get('fitness', float('inf'))) if feasible_runs else None
        
        summary = {
            "instance": instance,
            "total_runs": len(all_runs),
            "feasible_runs": len(feasible_runs),
            "infeasible_runs": len(all_runs) - len(feasible_runs),
            "has_feasible": len(feasible_runs) > 0,
            "all_runs_stats": {
                "avg_fitness": round(statistics.mean(all_fitnesses), 4) if all_fitnesses else None,
                "std_fitness": round(statistics.stdev(all_fitnesses), 4) if len(all_fitnesses) > 1 else 0.0,
                "min_fitness": round(min(all_fitnesses), 4) if all_fitnesses else None,
                "max_fitness": round(max(all_fitnesses), 4) if all_fitnesses else None,
                "avg_makespan": round(statistics.mean(all_makespans), 4) if all_makespans else None,
                "avg_runtime": round(statistics.mean(all_runtimes), 3) if all_runtimes else None,
            },
            "best_run_overall": best_run_overall,
            "best_feasible_run": best_feasible,
            "all_runs_details": all_runs
        }
        
        print(f"\nüèÜ BEST: Run {best_run_overall['run_number'] if best_run_overall else 'N/A'}")
        
        with open("summary.json", "w") as f:
            json.dump(summary, f, indent=2)
        with open("all_runs.json", "w") as f:
            json.dump(all_runs, f, indent=2)
        EOF
    
    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.instance }}
        path: |
          summary.json
          all_runs.json
        retention-days: 30

  aggregate:
    name: Create Master CSV (ALL Instances)
    needs: [run-small, run-medium, run-large]
    runs-on: ubuntu-latest
    
    steps:
    - name: Download all results
      uses: actions/download-artifact@v4
      with:
        pattern: result-*
        merge-multiple: false
    
    - name: Create CSV with ALL instances
      run: |
        python3 <<'EOF'
        import json, glob, csv, os
        
        summaries = []
        
        print("üîç Searching for summary.json files...")
        
        for result_dir in glob.glob("result-*"):
            summary_file = os.path.join(result_dir, "summary.json")
            
            if os.path.exists(summary_file):
                try:
                    with open(summary_file) as f:
                        data = json.load(f)
                        summaries.append(data)
                        instance = data.get('instance', 'unknown')
                        feas = data.get('feasible_runs', 0)
                        infeas = data.get('infeasible_runs', 0)
                        print(f"  ‚úÖ {instance}: {feas} feasible, {infeas} infeasible")
                except Exception as e:
                    print(f"  ‚ùå Failed: {summary_file} - {e}")
        
        print(f"\nüìä Total instances: {len(summaries)}")
        
        if not summaries:
            print("‚ùå No summaries found!")
            with open("MASTER_RESULTS.csv", "w") as f:
                f.write("Instance,Error\n")
                f.write("NO_RESULTS,No summary files found\n")
            exit(0)
        
        # S·∫Øp x·∫øp
        summaries.sort(key=lambda x: tuple(int(p) for p in x["instance"].split(".")))
        
        # ‚úÖ GHI T·∫§T C·∫¢ INSTANCES (k·ªÉ c·∫£ kh√¥ng c√≥ feasible)
        print(f"\n‚úÖ Processing ALL {len(summaries)} instances (including infeasible)")
        
        # T·∫°o CSV
        with open("MASTER_RESULTS.csv", "w", newline="", encoding="utf-8") as f:
            cols = [
                "Instance", "Size", "Vehicles", "Replica",
                "Total_Runs", "Feasible_Runs", "Infeasible_Runs", "Feasible_Ratio",
                
                # Best overall
                "Best_Overall_Run", "Best_Overall_Fitness", "Best_Overall_Feasible",
                
                # Best feasible (n·∫øu c√≥)
                "Best_Feasible_Run", "Best_Feasible_Fitness", "Best_Feasible_Makespan",
                
                # Stats ALL runs
                "All_Runs_Avg_Fitness", "All_Runs_Std_Fitness",
                "All_Runs_Min_Fitness", "All_Runs_Max_Fitness",
                "All_Runs_Avg_Makespan", "All_Runs_Avg_Runtime",
                
                # 5 runs details
                "Run1_Fitness", "Run1_Feasible",
                "Run2_Fitness", "Run2_Feasible",
                "Run3_Fitness", "Run3_Feasible",
                "Run4_Fitness", "Run4_Feasible",
                "Run5_Fitness", "Run5_Feasible",
            ]
            
            writer = csv.DictWriter(f, fieldnames=cols)
            writer.writeheader()
            
            for s in summaries:
                parts = s["instance"].split(".")
                
                best_overall = s.get("best_run_overall")
                best_feasible = s.get("best_feasible_run")
                all_stats = s.get("all_runs_stats", {})
                all_runs_details = s.get("all_runs_details", [])
                
                row = {
                    "Instance": s["instance"],
                    "Size": int(parts[0]),
                    "Vehicles": int(parts[1]),
                    "Replica": int(parts[2]),
                    
                    "Total_Runs": s["total_runs"],
                    "Feasible_Runs": s["feasible_runs"],
                    "Infeasible_Runs": s["infeasible_runs"],
                    "Feasible_Ratio": round(s["feasible_runs"] / s["total_runs"], 4) if s["total_runs"] > 0 else 0,
                    
                    # Best overall
                    "Best_Overall_Run": best_overall["run_number"] if best_overall else None,
                    "Best_Overall_Fitness": best_overall["fitness"] if best_overall else None,
                    "Best_Overall_Feasible": "YES" if best_overall and best_overall.get("feasible") else "NO",
                    
                    # Best feasible
                    "Best_Feasible_Run": best_feasible["run_number"] if best_feasible else None,
                    "Best_Feasible_Fitness": best_feasible["fitness"] if best_feasible else None,
                    "Best_Feasible_Makespan": best_feasible["makespan"] if best_feasible else None,
                    
                    # All runs stats
                    "All_Runs_Avg_Fitness": all_stats.get("avg_fitness"),
                    "All_Runs_Std_Fitness": all_stats.get("std_fitness"),
                    "All_Runs_Min_Fitness": all_stats.get("min_fitness"),
                    "All_Runs_Max_Fitness": all_stats.get("max_fitness"),
                    "All_Runs_Avg_Makespan": all_stats.get("avg_makespan"),
                    "All_Runs_Avg_Runtime": all_stats.get("avg_runtime"),
                }
                
                # Chi ti·∫øt 5 runs
                for run_idx in range(1, 6):
                    run_data = next((r for r in all_runs_details if r.get("run_number") == run_idx), None)
                    if run_data:
                        row[f"Run{run_idx}_Fitness"] = run_data.get("fitness")
                        row[f"Run{run_idx}_Feasible"] = "YES" if run_data.get("feasible") else "NO"
                    else:
                        row[f"Run{run_idx}_Fitness"] = None
                        row[f"Run{run_idx}_Feasible"] = "N/A"
                
                writer.writerow(row)
        
        print(f"\n‚úÖ MASTER CSV CREATED: {len(summaries)} instances")
        
        # Statistics
        total_feasible = sum(s["feasible_runs"] for s in summaries)
        total_runs = sum(s["total_runs"] for s in summaries)
        has_at_least_1 = sum(1 for s in summaries if s["feasible_runs"] > 0)
        all_feasible = sum(1 for s in summaries if s["feasible_runs"] == 5)
        no_feasible = sum(1 for s in summaries if s["feasible_runs"] == 0)
        
        print(f"\nüìà OVERALL STATISTICS:")
        print(f"   Total instances: {len(summaries)}")
        print(f"   Total runs: {total_runs}")
        print(f"   Total feasible runs: {total_feasible}/{total_runs} ({total_feasible/total_runs*100:.1f}%)")
        print(f"   Instances with ‚â•1 feasible: {has_at_least_1} ({has_at_least_1/len(summaries)*100:.1f}%)")
        print(f"   Instances with ALL feasible: {all_feasible} ({all_feasible/len(summaries)*100:.1f}%)")
        print(f"   Instances with NO feasible: {no_feasible} ({no_feasible/len(summaries)*100:.1f}%)")
        
        EOF
    
    - name: Upload master CSV
      uses: actions/upload-artifact@v4
      with:
        name: master-results-all
        path: MASTER_RESULTS.csv
        retention-days: 90