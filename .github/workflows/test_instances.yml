name: Test Tabu & Multilevel Tabu (50.10.1 & 50.20.1)

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  compile:
    name: Compile C++ Executables
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y g++ bc

    - name: Compile Tabu
      run: |
        g++ -O2 -std=c++17 -o tabu src/Tabu.cpp
        chmod +x tabu
        ls -lh tabu

    - name: Compile Multilevel Tabu
      run: |
        g++ -O2 -std=c++17 -o multilevel_tabu src/Multilevel_Tabu.cpp
        chmod +x multilevel_tabu
        ls -lh multilevel_tabu

    - name: Upload executables
      uses: actions/upload-artifact@v4
      with:
        name: tabu-executables
        path: |
          tabu
          multilevel_tabu
        retention-days: 1

  run-test:
    name: Run Instances
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 60

    strategy:
      matrix:
        exe: [tabu, multilevel_tabu]
        instance: [50.10.1, 50.20.1]
        run_id: [1, 2, 3]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download executables
      uses: actions/download-artifact@v4
      with:
        name: tabu-executables

    - name: Run instance
      run: |
        chmod +x ${{ matrix.exe }}
        INSTANCE="${{ matrix.instance }}"
        echo "üîÑ Running ${{ matrix.exe }} on $INSTANCE (run ${{ matrix.run_id }})"
        START_TIME=$(date +%s.%N)
        timeout 30m ./${{ matrix.exe }} instances/${INSTANCE}.txt > output_${{ matrix.exe }}_${INSTANCE}_run${{ matrix.run_id }}.txt 2>&1 || true
        END_TIME=$(date +%s.%N)
        RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
        echo "$RUNTIME" > runtime_${{ matrix.exe }}_${INSTANCE}_run${{ matrix.run_id }}.txt
        echo "‚è±Ô∏è  Run completed in ${RUNTIME}s"
        echo ""
        echo "üìã Last 20 lines of output:"
        tail -n 20 output_${{ matrix.exe }}_${INSTANCE}_run${{ matrix.run_id }}.txt
        echo ""
        echo "‚úÖ Run completed for ${{ matrix.exe }} on $INSTANCE (run ${{ matrix.run_id }})"

    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: results-${{ matrix.exe }}-${{ matrix.instance }}-run${{ matrix.run_id }}
        path: |
          output_${{ matrix.exe }}_${{ matrix.instance }}_run${{ matrix.run_id }}.txt
          runtime_${{ matrix.exe }}_${{ matrix.instance }}_run${{ matrix.run_id }}.txt
        retention-days: 30

  aggregate-results:
    name: Aggregate Results
    needs: run-test
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all results
      uses: actions/download-artifact@v4
      with:
        pattern: results-*
        path: results

    - name: Parse results and create summary
      run: |
        python3 <<'EOF'
        import re, json, os

        exes = ["tabu", "multilevel_tabu"]
        instances = ["50.10.1", "50.20.1"]
        runs = [1, 2, 3]
        all_runs = []

        def parse_output(output_file, runtime_file):
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_routes = []
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                        if line.startswith("Vehicle "):
                            match = re.match(r'Vehicle (\d+):\s*(.+)', line)
                            if match:
                                vehicle_routes.append(f"V{match.group(1)}:{match.group(2).strip()}")
                return {
                    "runtime": round(runtime, 3),
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "feasible": "YES" if (drone_viol < 0.01 and waiting_viol < 0.01) else "NO",
                    "routes": vehicle_routes
                }
            except Exception as e:
                return {
                    "runtime": 0, "makespan": 0, "drone_violation": 0,
                    "waiting_violation": 0, "fitness": float('inf'),
                    "feasible": "ERROR", "routes": [], "error": str(e)
                }

        print(f"\n{'='*60}")
        print(f"üìä AGGREGATED RESULTS")
        print(f"{'='*60}\n")

        for exe in exes:
            for inst in instances:
                for run_id in runs:
                    output_file = f"results/results-{exe}-{inst}-run{run_id}/output_{exe}_{inst}_run{run_id}.txt"
                    runtime_file = f"results/results-{exe}-{inst}-run{run_id}/runtime_{exe}_{inst}_run{run_id}.txt"
                    result = parse_output(output_file, runtime_file)
                    result["exe"] = exe
                    result["instance"] = inst
                    result["run_id"] = run_id
                    all_runs.append(result)
                    print(f"{exe} | {inst} | Run {run_id}:")
                    print(f"  Runtime: {result['runtime']}s")
                    print(f"  Fitness: {result['fitness']}")
                    print(f"  Makespan: {result['makespan']}")
                    print(f"  Drone Violation: {result['drone_violation']}")
                    print(f"  Waiting Violation: {result['waiting_violation']}")
                    print(f"  Feasible: {result['feasible']}")
                    print(f"  Routes: {len(result['routes'])} vehicles")
                    if result['routes']:
                        print(f"  First 3 routes:")
                        for route in result['routes'][:3]:
                            print(f"    {route}")
                    print()

        # Save to JSON
        with open("test_results_all.json", "w") as f:
            json.dump({
                "runs": all_runs
            }, f, indent=2)

        print(f"\n‚úÖ Results saved to test_results_all.json")
        EOF

    - name: Export summary to CSV
      run: |
        python3 <<'EOF'
        import json
        import csv

        with open("test_results_all.json", "r") as f:
            data = json.load(f)

        with open("test_results_summary.csv", "w", newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow([
                "exe", "instance", "run_id", "runtime", "makespan",
                "drone_violation", "waiting_violation", "fitness", "feasible", "routes"
            ])
            for run in data["runs"]:
                writer.writerow([
                    run.get("exe", ""),
                    run.get("instance", ""),
                    run.get("run_id", ""),
                    run.get("runtime", ""),
                    run.get("makespan", ""),
                    run.get("drone_violation", ""),
                    run.get("waiting_violation", ""),
                    run.get("fitness", ""),
                    run.get("feasible", ""),
                    len(run.get("routes", []))
                ])
        print("‚úÖ Exported test_results_summary.csv")
        EOF

    - name: Upload CSV summary
      uses: actions/upload-artifact@v4
      with:
        name: test-results-csv
        path: test_results_summary.csv
        retention-days: 30