name: Test Single Instance (50.40.1)

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  compile:
    name: Compile C++
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y g++ bc

    - name: Compile executable
      run: |
        g++ -O2 -std=c++17 -o multilevel_tabu src/Multilevel_Tabu.cpp
        chmod +x multilevel_tabu
        ls -lh multilevel_tabu

    - name: Upload executable
      uses: actions/upload-artifact@v4
      with:
        name: multilevel-executable
        path: multilevel_tabu
        retention-days: 1

  run-test:
    name: Run 50.40.1 (segments=${{ matrix.segment }})
    needs: compile
    runs-on: ubuntu-latest
    timeout-minutes: 60

    strategy:
      matrix:
        segment: [150, 200, 250]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download executable
      uses: actions/download-artifact@v4
      with:
        name: multilevel-executable

    - name: Run instance
      run: |
        chmod +x multilevel_tabu

        INSTANCE="50.40.1"
        SEGMENT="${{ matrix.segment }}"
        echo "üîÑ Running instance ${INSTANCE} with SEGMENT=${SEGMENT}..."

        START_TIME=$(date +%s.%N)
        timeout 18m ./multilevel_tabu instances/${INSTANCE}.txt --segment $SEGMENT > output_seg${SEGMENT}.txt 2>&1 || true
        END_TIME=$(date +%s.%N)
        RUNTIME=$(echo "$END_TIME - $START_TIME" | bc)
        echo "$RUNTIME" > runtime_seg${SEGMENT}.txt

        echo "‚è±Ô∏è  Run completed in ${RUNTIME}s"

        # Show last 20 lines of output
        echo ""
        echo "üìã Last 20 lines of output:"
        tail -n 20 output_seg${SEGMENT}.txt

        echo ""
        echo "‚úÖ Run completed for SEGMENT=${SEGMENT}!"

    - name: Upload results for segment
      uses: actions/upload-artifact@v4
      with:
        name: results-segment-${{ matrix.segment }}
        path: |
          output_seg${{ matrix.segment }}.txt
          runtime_seg${{ matrix.segment }}.txt
        retention-days: 30

  aggregate-results:
    name: Aggregate Results
    needs: run-test
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all segment results
      uses: actions/download-artifact@v4
      with:
        pattern: results-segment-*
        path: results

    - name: Parse results and create summary
      run: |
        python3 <<'EOF'
        import re, json, os

        instance = "50.40.1"
        segments = [150, 200, 250]
        all_runs = []

        def parse_output(output_file, runtime_file):
            try:
                with open(output_file, "r") as f:
                    content = f.read()
                runtime = 0.0
                if os.path.exists(runtime_file):
                    with open(runtime_file, "r") as f:
                        runtime = float(f.read().strip())
                last_route_idx = content.rfind("Route details:")
                makespan = drone_viol = waiting_viol = fitness = 0.0
                vehicle_routes = []
                if last_route_idx != -1:
                    solution_section = content[last_route_idx:]
                    for line in solution_section.split('\n'):
                        if "Makespan:" in line:
                            m = re.search(r'Makespan:\s*([\d.]+)', line)
                            if m: makespan = float(m.group(1))
                        if "Drone violation:" in line:
                            m = re.search(r'Drone violation:\s*([\d.]+)', line)
                            if m: drone_viol = float(m.group(1))
                        if "Waiting violation:" in line:
                            m = re.search(r'Waiting violation:\s*([\d.]+)', line)
                            if m: waiting_viol = float(m.group(1))
                        if "Fitness:" in line:
                            m = re.search(r'Fitness:\s*([\d.]+)', line)
                            if m: fitness = float(m.group(1))
                        if line.startswith("Vehicle "):
                            match = re.match(r'Vehicle (\d+):\s*(.+)', line)
                            if match:
                                vehicle_routes.append(f"V{match.group(1)}:{match.group(2).strip()}")
                return {
                    "runtime": round(runtime, 3),
                    "makespan": round(makespan, 4),
                    "drone_violation": round(drone_viol, 4),
                    "waiting_violation": round(waiting_viol, 4),
                    "fitness": round(fitness, 4),
                    "feasible": "YES" if (drone_viol < 0.01 and waiting_viol < 0.01) else "NO",
                    "routes": vehicle_routes
                }
            except Exception as e:
                return {
                    "runtime": 0, "makespan": 0, "drone_violation": 0,
                    "waiting_violation": 0, "fitness": float('inf'),
                    "feasible": "ERROR", "routes": [], "error": str(e)
                }

        print(f"\n{'='*60}")
        print(f"üìä RESULTS FOR {instance}")
        print(f"{'='*60}\n")

        for seg in segments:
            result = parse_output(f"results/results-segment-{seg}/output_seg{seg}.txt", f"results/results-segment-{seg}/runtime_seg{seg}.txt")
            result["segment"] = seg
            all_runs.append(result)
            print(f"Segment {seg}:")
            print(f"  Runtime: {result['runtime']}s")
            print(f"  Fitness: {result['fitness']}")
            print(f"  Makespan: {result['makespan']}")
            print(f"  Drone Violation: {result['drone_violation']}")
            print(f"  Waiting Violation: {result['waiting_violation']}")
            print(f"  Feasible: {result['feasible']}")
            print(f"  Routes: {len(result['routes'])} vehicles")
            if result['routes']:
                print(f"  First 3 routes:")
                for route in result['routes'][:3]:
                    print(f"    {route}")
            print()

        # Save to JSON
        with open("test_results.json", "w") as f:
            json.dump({
                "instance": instance,
                "segments": segments,
                "runs": all_runs
            }, f, indent=2)

        print(f"\n‚úÖ Results saved to test_results.json")
        EOF

    - name: Create simple CSV
      run: |
        python3 <<'EOF'
        import json, csv

        with open("test_results.json") as f:
            data = json.load(f)

        instance = data["instance"]
        segments = data["segments"]

        def calculate_vehicle_distribution(num_customers):
            if 6 <= num_customers <= 12:
                pairs = 1
            elif num_customers <= 20:
                pairs = 2
            elif num_customers <= 50:
                pairs = 3
            elif num_customers <= 100:
                pairs = 4
            else:
                pairs = 0
            return pairs, pairs

        parts = instance.split(".")
        size = int(parts[0])
        replica = int(parts[2])
        num_tech, num_drone = calculate_vehicle_distribution(size)

        with open("test_results.csv", "w", newline="", encoding="utf-8") as f:
            cols = [
                "Instance", "Size", "Num_Technician", "Num_Drone", "Replica", "Segment",
                "Runtime_s", "Makespan", "Drone_Violation", "Waiting_Violation",
                "Fitness", "Feasible"
            ]
            writer = csv.DictWriter(f, fieldnames=cols)
            writer.writeheader()
            for run_data in data["runs"]:
                writer.writerow({
                    "Instance": instance,
                    "Size": size,
                    "Num_Technician": num_tech,
                    "Num_Drone": num_drone,
                    "Replica": replica,
                    "Segment": run_data["segment"],
                    "Runtime_s": run_data["runtime"],
                    "Makespan": run_data["makespan"],
                    "Drone_Violation": run_data["drone_violation"],
                    "Waiting_Violation": run_data["waiting_violation"],
                    "Fitness": run_data["fitness"],
                    "Feasible": run_data["feasible"]
                })
        print("‚úÖ CSV created: test_results.csv")
        EOF

    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: test-results-50.40.1
        path: |
          test_results.json
          test_results.csv
          results/**
        retention-days: 30

    - name: Display CSV content
      run: |
        echo ""
        echo "üìÑ CSV Content:"
        cat test_results.csv